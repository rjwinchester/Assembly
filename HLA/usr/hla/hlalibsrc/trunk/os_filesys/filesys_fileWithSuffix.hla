
// I, Randall Hyde, hereby agree to waive all claim of copyright (economic
// and moral) in all content contributed by me, the user, and immediately
// place any and all contributions by me into the public domain; I grant
// anyone the right to use my work for any purpose, without any
// conditions, to be changed or destroyed in any manner whatsoever
// without any attribution or notice to the creator.  I also absolve myself
// of any responsibility for the use of this code, the user assumes all
// responsibilities for using this software in an appropriate manner.
//
// Notice of declaration of public domain, 7/12/2006, by Randall Hyde



unit FileIOUnit;
		
#include( "excepts.hhf" )
#include( "../include/fileiounit.hhf" )
#include( "os.hhf" )

/****************************************************************/
/*                                                              */
/* fileWithSuffix-                                              */
/*                                                              */
/* Returns all the files in the current working directory that  */
/* have the suffix specified by the parameter string. Note that */
/* the suffix is just a trailing set of characters, no '.' is   */
/* implied by the use of this term. The suffix string should    */
/* contain a leading "." character if you expect the suffix to  */
/* immediately follow a '.'                                     */
/*                                                              */
/****************************************************************/



#if( os.win32 )

	iterator filesys.fileWithSuffix
	( 
		directory	:string; 
		suffix		:string 
	); 
		@nodisplay;
		@noframe;
		
	var
		eaxSave		:dword;
		ecxSave		:dword;
		edxSave		:dword;
		handle		:dword;
		wildCard	:string;
		FileData	:win.Win32FindData;
		wd			:string;
		
	begin fileWithSuffix;

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		mov( edx, edxSave );
		mov( ecx, ecxSave );
		mov( eax, eaxSave );
		
		str.talloc( 1024 );
		mov( eax, wildCard );
		
		str.cpy( directory, wildCard );
		
		// If the directory string is empty, then don't
		// stick a "\" at the beginning of the name, use
		// the current working directory.
		
		mov( wildCard, eax );
		mov( (type str.strRec [eax]).length, ecx );
		test( ecx, ecx );
		jz haveSeparator;
				
		// Quick check to make sure we don't overflow wildcard:
		
		cmp( ecx, 1000 );
		jae StringOverflow;
		
		// Okay, tack on a "\*" to the path supplied (no '\' if
		// there is already one present):
		
		mov( [eax+ecx-1], dl );
		cmp( dl, '/' );
		je haveSeparator;
		cmp( dl, '\' );
		je haveSeparator;

			str.cat( "\*", wildCard );
			jmp havePath;
			
		haveSeparator:
		
			// directory already has a "/" or "\" suffix,
			// so just add "*":
			
			str.cat( "*", wildCard );
			
		havePath:
		
		// Now append the suffix to the wildcard string.
		//
		// Make sure we have room to append the suffix:
		
		mov( (type str.strRec [eax]).length, ecx );
		mov( suffix, edx );
		add( (type str.strRec [edx]).length, ecx );
		cmp( ecx, (type str.strRec [eax]).maxlen );
		jae StringOverflow;
		
		str.cat( suffix, wildCard );
		 
		// Find the first matching file (if one exists).
		// Save the handle for use by FindNextFile.
		
		win.FindFirstFile( wildCard, FileData );
		mov( eax, handle );
		
		// If we matched at least one filename, return
		// the corresponding string and call the
		// FindNextFile routine to match any additional
		// filenames.
		
		cmp( eax, win.INVALID_HANDLE_VALUE );
		je allDone;
		
			repeatUntilNoMore:
			
				mov( FileData.FileAttributes, eax );
				and
				( 
						win.FILE_ATTRIBUTE_DIRECTORY
					|	win.FILE_ATTRIBUTE_HIDDEN
					|	win.FILE_ATTRIBUTE_SYSTEM, 
					eax 
				);
				jnz notAFile;
				
					// FindFirstFile & FindNextFile return
					// zero-terminated strings.  Convert these
					// to HLA compatible strings and return
					// the converted string:
					
					lea( eax, FileData.FileName );
					str.a_cpyz( eax );

					// Return the converted string to the FOREACH
					// loop and then free the storage associated
					// with the string.
					
					mov( ecxSave, ecx );
					mov( edxSave, edx );
					yield();		// Return string to FOREACH loop.
					mov( edx, edxSave );
					mov( ecx, ecxSave );
				
				// Get the next filename in the list:
				
				notAFile:
				win.FindNextFile( handle, FileData );
				cmp( al, false );
				jne repeatUntilNoMore;

			
			
			// When we've processed all the filenames in the list,
			// call FindClose to free the handle and other resources.
			
			win.FindClose( handle );
			
		allDone:
		mov( edxSave, edx );
		mov( ecxSave, ecx );
		mov( eaxSave, eax );
		leave();
		add( 4, esp );		// Remove ptr to foreach body.
		ret( _parms_ );
		
	StringOverflow:
		raise( ex.StringOverflow );

	end fileWithSuffix;
	
#elseif( os.linux )

	iterator filesys.fileWithSuffix
	( 
		directory	:string;
		suffix		:string 
	); 
		@nodisplay;
		@noframe;
		
	var
		handle		:dword;
		filename	:string;
		dirStr		:string;
		suffixLen	:dword;
		eaxSave		:dword;
		ebxSave		:dword;
		ecxSave		:dword;
		edxSave		:dword;
		ediSave		:dword;
		esiSave		:dword;
		s			:linux.stat64_t;
		dBuf		:byte[4096];
		dirBuf		:byte[1024];
		fnBuf		:byte[1024];

	readonly
		curDir		:string := ".";		
		
	begin fileWithSuffix;

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		mov( esi, esiSave );
		mov( edi, ediSave );
		mov( edx, edxSave );
		mov( ecx, ecxSave );
		mov( ebx, ebxSave );
		mov( eax, eaxSave );
		pushfd();
		
		str.init( dirBuf, 1016 );	// Must be at least 1 less than true length.
		mov( eax, dirStr );
		str.init( fnBuf, 1024 );
		mov( eax, filename );
		
		str.length( suffix );
		mov( eax, suffixLen );
		
		mov( directory, eax );
		test( eax, eax );
		jz emptyString;
		cmp( (type str.strRec [eax]).length, 0 );
		jne notEmptyString;
		
		emptyString:
			mov( curDir, eax );
			mov( eax, directory );
			
		notEmptyString:
		mov( dirStr, eax );
		str.cpy( directory, eax );
		mov( (type str.strRec [eax]).length, ecx );
		cmp( (type byte [eax+ecx-1]), '/' );
		je haveSlash;
		
			mov( '/', (type char [eax+ecx]));
			mov( 0, (type char [eax+ecx+1]));
			inc( (type str.strRec [eax]).length );
			
		haveSlash:		
		
		linux.open( directory, linux.o_rdonly, linux.s_irwxu );
		mov( eax, handle );
		test( eax, eax );
		jz openFailed;

			forAllEntries:

				linux.getdents
				( 
					handle, 
					(type linux.dirent64 dBuf), 
					@size(dBuf) 
				);
				cmp( eax, 0 );
				jle noFiles;
				mov( eax, ecx );
				lea( ebx, dBuf );
				repeatUntilECXle0:

					str.cpy( dirStr, filename );
					lea( eax, (type linux.dirent64 [ebx]).d_name );
					str.catz( eax, filename ); 
					lea( edx, s );
					linux.stat( filename, [edx] );
					test( eax, eax );
					js noFiles;
					mov( s.st_mode, eax );
					and( linux.s_ifreg, eax );
					jz tryNextEnt;
					
					mov( filename, esi );
					mov( (type str.strRec [esi]).length, eax );
					cmp( eax, suffixLen );
					jb tryNextEnt;
					
						push( ecx );
						mov( suffixLen, ecx );
						test( ecx, ecx );
						jz doYield;
						add( (type str.strRec [esi]).length, esi );
						sub( ecx, esi );
						mov( suffix, edi );
						cld();
						repe.cmpsb();
						jne dontYield;
						
						doYield:
						
							// Need to return the filename without
							// the directory prefix:
							
							lea( eax, (type linux.dirent64 [ebx]).d_name );
							str.a_cpyz( eax );
							
							push( ebx );
							mov( esiSave, esi );
							mov( ediSave, edi );
							mov( edxSave, edx );
							mov( ecxSave, ecx );
							mov( ebxSave, ebx );
							yield();
							mov( esi, esiSave );
							mov( edi, ediSave );
							mov( edx, edxSave );
							mov( ecx, ecxSave );
							mov( ebx, ebxSave );
							pop( ebx );
							
						dontYield:
							pop( ecx );
						
						
					tryNextEnt:
					movzx( (type linux.dirent64[ebx]).d_reclen, edx );
					add( edx, ebx );
					sub( edx, ecx );
					cmp( ecx, 0 );
					jg repeatUntilECXle0; 

				jmp forAllEntries;

			noFiles:
			linux.close(handle);
			
		openFailed:
		mov( esiSave, esi );
		mov( ediSave, edi );
		mov( edxSave, edx );
		mov( ecxSave, ecx );
		mov( ebxSave, ebx );
		mov( eaxSave, eax );
		popfd();
		leave();
		add( 4, esp );		// Remove ptr to foreach body
		ret( _parms_ );

	end fileWithSuffix;

#elseif( os.freeBSD )

	iterator filesys.fileWithSuffix
	( 
		directory	:string;
		suffix		:string 
	); 
		@nodisplay;
		@noframe;
		
	var
		handle		:dword;
		filename	:string;
		dirStr		:string;
		suffixLen	:dword;
		eaxSave		:dword;
		ebxSave		:dword;
		ecxSave		:dword;
		edxSave		:dword;
		ediSave		:dword;
		esiSave		:dword;
		s			:bsd.stat_t;
		dBuf		:byte[4096];
		dirBuf		:byte[1024];
		fnBuf		:byte[1024];

	readonly
		curDir		:string := ".";		
		
		
	begin fileWithSuffix;

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		mov( esi, esiSave );
		mov( edi, ediSave );
		mov( edx, edxSave );
		mov( ecx, ecxSave );
		mov( ebx, ebxSave );
		mov( eax, eaxSave );
		pushfd();
		
		str.init( dirBuf, 1016 );	// Must be at least 1 less than true length.
		mov( eax, dirStr );
		str.init( fnBuf, 1024 );
		mov( eax, filename );
		
		str.length( suffix );
		mov( eax, suffixLen );
		
		mov( directory, eax );
		test( eax, eax );
		jz emptyString;
		cmp( (type str.strRec [eax]).length, 0 );
		jne notEmptyString;
		
		emptyString:
			mov( curDir, eax );
			mov( eax, directory );
			
		notEmptyString:
		mov( dirStr, eax );
		str.cpy( directory, eax );
		mov( (type str.strRec [eax]).length, ecx );
		cmp( (type byte [eax+ecx-1]), '/' );
		je haveSlash;
		
			mov( '/', (type char [eax+ecx]));
			mov( 0, (type char [eax+ecx+1]));
			inc( (type str.strRec [eax]).length );
			
		haveSlash:		
		
		bsd.open( directory, bsd.O_RDONLY, bsd.S_IRWXU );
		mov( eax, handle );
		jc openFailed;

			forAllEntries:

				bsd.getdents
				( 
					handle, 
					(type bsd.dirent dBuf), 
					@size(dBuf) 
				);
				jc noFiles;
				test( eax, eax );
				jz noFiles;
				
				mov( eax, ecx );
				lea( ebx, dBuf );
				repeatUntilECXle0:

					str.cpy( dirStr, filename );
					lea( eax, (type bsd.dirent [ebx]).d_name );
					str.catz( eax, filename ); 
					lea( edx, s );
					bsd.stat( filename, [edx] );
					jc noFiles;
					movzx( s.st_mode, eax );
					and( bsd.S_IFREG, eax );
					jz tryNextEnt;
					
					mov( filename, esi );
					mov( (type str.strRec [esi]).length, eax );
					cmp( eax, suffixLen );
					jb tryNextEnt;
					
						push( ecx );
						mov( suffixLen, ecx );
						test( ecx, ecx );
						jz doYield;
						add( (type str.strRec [esi]).length, esi );
						sub( ecx, esi );
						mov( suffix, edi );
						cld();
						repe.cmpsb();
						jne dontYield;
						
						doYield:
						
							// Need to return the filename without
							// the directory prefix:
							
							lea( eax, (type bsd.dirent [ebx]).d_name );
							str.a_cpyz( eax );
							
							push( ebx );
							mov( esiSave, esi );
							mov( ediSave, edi );
							mov( edxSave, edx );
							mov( ecxSave, ecx );
							mov( ebxSave, ebx );
							yield();
							mov( esi, esiSave );
							mov( edi, ediSave );
							mov( edx, edxSave );
							mov( ecx, ecxSave );
							mov( ebx, ebxSave );
							pop( ebx );
							
						dontYield:
						pop( ecx );
						
					tryNextEnt:
					movzx( (type bsd.dirent [ebx]).d_reclen, edx );
					add( edx, ebx );
					sub( edx, ecx );
					cmp( ecx, 0 );
					jg repeatUntilECXle0; 

				jmp forAllEntries;

		  noFiles:
		    bsd.close(handle);
		    
		openFailed:
		mov( esiSave, esi );
		mov( ediSave, edi );
		mov( edxSave, edx );
		mov( ecxSave, ecx );
		mov( ebxSave, ebx );
		mov( eaxSave, eax );
		popfd();
		leave();
		add( 4, esp );		// Remove ptr to foreach body
		ret( _parms_ );

	end fileWithSuffix;

#elseif( os.macOS )

	iterator filesys.fileWithSuffix
	( 
		directory	:string;
		suffix		:string 
	); 
		@nodisplay;
		@noframe;
		
	var
		handle		:dword;
		filename	:string;
		dirStr		:string;
		suffixLen	:dword;
		eaxSave		:dword;
		ebxSave		:dword;
		ecxSave		:dword;
		edxSave		:dword;
		ediSave		:dword;
		esiSave		:dword;
		s			:mac.stat_t;
		dBuf		:byte[4096];
		dirBuf		:byte[1024];
		fnBuf		:byte[1024];

	readonly
		curDir		:string := ".";		
		
		
	begin fileWithSuffix;

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		mov( esi, esiSave );
		mov( edi, ediSave );
		mov( edx, edxSave );
		mov( ecx, ecxSave );
		mov( ebx, ebxSave );
		mov( eax, eaxSave );
		pushfd();
		
		str.init( dirBuf, 1016 );	// Must be at least 1 less than true length.
		mov( eax, dirStr );
		str.init( fnBuf, 1024 );
		mov( eax, filename );
		
		str.length( suffix );
		mov( eax, suffixLen );
		
		mov( directory, eax );
		test( eax, eax );
		jz emptyString;
		cmp( (type str.strRec [eax]).length, 0 );
		jne notEmptyString;
		
		emptyString:
			mov( curDir, eax );
			mov( eax, directory );
			
		notEmptyString:
		mov( dirStr, eax );
		str.cpy( directory, eax );
		mov( (type str.strRec [eax]).length, ecx );
		cmp( (type byte [eax+ecx-1]), '/' );
		je haveSlash;
		
			mov( '/', (type char [eax+ecx]));
			mov( 0, (type char [eax+ecx+1]));
			inc( (type str.strRec [eax]).length );
			
		haveSlash:		
		
		mac.open( directory, mac.O_RDONLY, mac.S_IRWXU );
		mov( eax, handle );
		jc openFailed;

			forAllEntries:

				mac.getdents
				( 
					handle, 
					(type mac.dirent dBuf), 
					@size(dBuf) 
				);
				jc noFiles;
				test( eax, eax );
				jz noFiles;
				
				mov( eax, ecx );
				lea( ebx, dBuf );
				repeatUntilECXle0:

					str.cpy( dirStr, filename );
					lea( eax, (type mac.dirent [ebx]).d_name );
					str.catz( eax, filename ); 
					lea( edx, s );
					mac.stat( filename, [edx] );
					jc noFiles;
					movzx( s.st_mode, eax );
					and( mac.S_IFREG, eax );
					jz tryNextEnt;
					
					mov( filename, esi );
					mov( (type str.strRec [esi]).length, eax );
					cmp( eax, suffixLen );
					jb tryNextEnt;
					
						push( ecx );
						mov( suffixLen, ecx );
						test( ecx, ecx );
						jz doYield;
						add( (type str.strRec [esi]).length, esi );
						sub( ecx, esi );
						mov( suffix, edi );
						cld();
						repe.cmpsb();
						jne dontYield;
						
						doYield:
						
							// Need to return the filename without
							// the directory prefix:
							
							lea( eax, (type mac.dirent [ebx]).d_name );
							str.a_cpyz( eax );
							
							push( ebx );
							mov( esiSave, esi );
							mov( ediSave, edi );
							mov( edxSave, edx );
							mov( ecxSave, ecx );
							mov( ebxSave, ebx );
							yield();
							mov( esi, esiSave );
							mov( edi, ediSave );
							mov( edx, edxSave );
							mov( ecx, ecxSave );
							mov( ebx, ebxSave );
							pop( ebx );
						
						dontYield:
							pop( ecx );
						
					tryNextEnt:
					movzx( (type mac.dirent [ebx]).d_reclen, edx );
					add( edx, ebx );
					sub( edx, ecx );
					cmp( ecx, 0 );
					jg repeatUntilECXle0; 

				jmp forAllEntries;

		  noFiles:
		    mac.close(handle);
		    
		openFailed:
		mov( esiSave, esi );
		mov( ediSave, edi );
		mov( edxSave, edx );
		mov( ecxSave, ecx );
		mov( ebxSave, ebx );
		mov( eaxSave, eax );
		popfd();
		leave();
		add( 4, esp );		// Remove ptr to foreach body
		ret( _parms_ );

	end fileWithSuffix;

#else

	#print( "Unknown OS!" )
	
#endif

end FileIOUnit;

