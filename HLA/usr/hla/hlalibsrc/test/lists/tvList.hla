program list_test;
#include( "stdlib.hhf" )

const
	mneax	:text := "(type nodePtr eax)";
	mnebx	:text := "(type nodePtr ebx)";
	
type
	myNode	:class inherits( node )
					
				var
					i			:int32;
					
				static
					createCnt	:int32;
					
				override procedure create;
				override method cmpNodes;
				override method destroy;
				
			endclass;

	mnPtr	:pointer to myNode;
	
static
	vmt( myNode );
	n1	:mnPtr;
	n2	:mnPtr;
	n3	:mnPtr;
	n	:mnPtr[16];
	
	l	:pointer to virtualList_t;			
			
procedure myNode.create;
begin create;

	push( eax );
	test( esi, esi );
	jnz haveObjPtr;
	
		mov( malloc( @size( myNode ) ), esi );
		
	haveObjPtr:
	
	// Initialize the pointer to the VMT:
	
	mov( &myNode._VMT_, this._pVMT_ );
	
	// Initialize the number of nodes currently in the list:
	
	mov( this.createCnt, eax );
	mov( eax, this.i );
	inc( this.createCnt );

	pop( eax );
	
end create;

// Destroy doesn't have to do anything for this test,
// but because it's an abstract method, we have to
// supply *something*.

method myNode.destroy;
begin destroy;
end destroy;


method myNode.cmpNodes( n:nodePtr );
begin cmpNodes;

	push( eax );
	push( ebx );
	mov( n, ebx );
	mov( this.i, eax );
	cmp( eax, (type myNode [ebx]).i );
	pop( ebx );
	pop( eax );
	
end cmpNodes;


	
begin list_test;

	for( mov( 0, ecx ); ecx < 16; inc(ecx)) do
	
		myNode.create();
		mov( esi, n[ecx*4] );
		
	endfor;
	
	virtualList_t.create();
	mov( esi, l );
	
	// Do some quick checks on an empty list:
	
	l.numNodes();
	if( eax <> 0 ) then
		
		stderr.put( "list.numNodes didn't return zero on an empty list!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
	foreach l.nodeInList() do
	
		stderr.put( "list.nodeInList shouldn't iterate on an empty list!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
	
	endfor;
	
	// Okay, start off by inserting n[0] into the list using a huge index.
	// This should be okay, just creating the list containing n1.
	
	l.append( n[4], 100 );
	
	// append n[8] after n[4]:
	
	l.append( n[8], n[4] );
	
	// append n[12] to end of list:
	
	l.append( n[12] );
	
	// Verify that we have three nodes and that they are in the proper order:
	
	l.numNodes();
	if( eax <> 3 ) then
		
		stderr.put( "list.numNodes didn't return three!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
	mov( 1, ecx );
	foreach l.nodeInList() do
	
		if( esi <> n[ecx*4] ) then
		
			stderr.put( "list.nodeInList failure!" nl );
			stderr.put( "ecx = ", ecx, nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);
			
		endif;
		inc( ecx );
		
	endfor;
	stderr.put( "virtualList_append succeeded!" nl );
	
	
	
	// Test list.insert:
	
	l.insert( n[20], 100 );		// Append n[20] to the end of the list
	l.insert( n[16], n[20] );	// Insert n[16] before n[20]
	l.insert( n[0] );			// Insert n[0] at the beginning of the list. 
	
	
	// Verify that we have six nodes and that they are in the proper order:
	
	l.numNodes();
	if( eax <> 6 ) then
		
		stderr.put( "list.numNodes didn't return six!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
	mov( 0, ecx );
	foreach l.nodeInList() do
	
		if( esi <> n[ecx*4] ) then
		
			stderr.put( "list.nodeInList failure!" nl );
			stderr.put( "ecx = ", ecx, nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);
			
		endif;
		inc( ecx );
		
	endfor;
	stderr.put( "virtualList_insert succeeded!" nl );
	
	
	// test list.index
	
	for( mov(0, ecx); ecx < 6; inc( ecx )) do
	
		l.index( ecx );
		if( esi <> n[ecx*4] ) then
		
			stderr.put( "list.index failed!" nl );
			stderr.put( "ecx = ", ecx, nl );
			stderr.put( "esi = ", esi, nl );
			stderr.put( "n[ecx]=", n[ecx*4], nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);

		endif;
		
	endfor;
	stderr.put( "virtualList_index succeeded!" nl );
	
	
	// Test list.delete:
	
	l.delete( 4 );		// Delete n[16]
	if( esi <> n[16] ) then
	
		stderr.put( "list.delete failed to delete n[16]!" nl );
		stderr.put( "ecx = ", ecx, nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
	
	endif;
	
	l.delete( n[20] );		// Delete n[20]
	if( esi <> n[20] ) then
	
		stderr.put( "list.delete failed to delete n[20]!" nl );
		stderr.put( "ecx = ", ecx, nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
	
	endif;
	
	
	l.delete();		// Delete n[0]
	if( esi <> n[0] ) then
	
		stderr.put( "list.delete failed to delete n[0]!" nl );
		stderr.put( "ecx = ", ecx, nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
	
	endif;
	
	l.deleteLast();		// Delete n[12]
	
	mov( 1, ecx );
	foreach l.nodeInList() do
	
		if( esi <> n[ecx*4] ) then
		
			stderr.put( "list.nodeInList failure(2)!" nl );
			stderr.put( "ecx = ", ecx, nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);
			
		endif;
		inc( ecx );
		
	endfor;
	if( ecx <> 3 ) then
	
		stderr.put( "list.delete operation failed!" nl );
		stderr.put( "ecx = ", ecx, nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);

	endif;
	stderr.put( "virtualList.delete succeeded!" nl );
	
	
	// Test the reverse operation:
	
	l.destroy();
	l.create();
	for( mov( 0, ecx ); ecx < 16; inc( ecx )) do
	
		l.append( n[ecx*4] );
	
	endfor;
	
	l.reverse();
	

	mov( 0, ecx );
	foreach l.nodeInListReversed() do
	
		mov( (type myNode [esi]).i, eax );
		mov( n[ecx*4], ebx );
	   if( eax <> (type myNode [ebx]).i ) then
	   
			stderr.put( "list.reverse failed!" nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);

	   endif;
	   inc( ecx );
	   
	endfor;
	stderr.put( "virtualList.reverse succeeded!" nl );
	
	
	
	// Test the xchgNodes operation:
	
	l.destroy();
	l.create();		// Create an empty list.
	for( mov( 0, ecx ); ecx < 16; inc( ecx )) do
	
		l.append( n[ecx*4] );
	
	endfor;
	mov( n[0], ecx );
	mov( n[15*4], edx );
	for( mov( 0, ebx ); ebx < 8; inc( ebx )) do
	
		push( (type myNode [ecx]).Next );
		push( (type myNode [edx]).Prev );
		l.xchgNodes( ecx, edx );
		pop( edx );
		pop( ecx );
		
	endfor;
	mov( 15, ecx );
	foreach l.nodeInList() do
	
		mov( (type myNode [esi]).i, eax );
		mov( n[ecx*4], ebx );
		mov( (type myNode [ebx]).i, ebx );
		if( eax <> ebx ) then
		
			stderr.put( "list.xchgNodes failed!" nl );
			stderr.put( "ecx = ", ecx, nl );
			stderr.put( "eax = ", eax, nl );
			stderr.put( "ebx = ", ebx, nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);
			
		endif;
		dec( ecx );
		
	endfor;
	stderr.put( "virtualList.xchgNodes succeeded!" nl );





	// Test the sort operation:
	
	l.destroy();
	l.create();		// Create an empty list.
	
	// Test sorting an empty list:
	
	l.sort();		// Sort an empty list.
	l.numNodes();
	if( eax <> 0 ) then
	
		stderr.put( "list.sort on empty list should yield an empty list!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
	// Test sorting a singleton list:
	
	l.append( n[15*4] );
	l.sort();
	l.numNodes();
	if( eax <> 1 ) then
	
		stderr.put( "list.sort on singleton list should yield that singleton!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	mov( l, esi );
	mov( (type list [esi]).Head, eax );
	if( (type myNode [eax]).i <> 15 ) then
	
	
		stderr.put( "list.sort on singleton list failed!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
		
	// Test sorting a two-element list:
	
	l.append( n[14*4] );	
	l.sort();
	l.numNodes();
	if( eax <> 2 ) then
	
		stderr.put( "list.sort on two-item list should yield two nodes!" nl );
		stderr.put( "eax=", eax, nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	mov( l, esi );
	mov( (type list [esi]).Head, eax );
	mov( (type list [esi]).Tail, ebx );
	if( (type myNode [eax]).i <> 14 && (type myNode [eax]).i <> 15 ) then
	
		stderr.put( "list.sort on two-item list failed!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
		
	// Test sorting a three-element list:
	
	l.reverse();			// Unsort the data.
	l.append( n[13*4] );	
	l.sort();
	l.numNodes();
	if( eax <> 3 ) then
	
		stderr.put( "list.sort on three-item list should yield three nodes!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	mov( l, esi );
	mov( (type list [esi]).Head, eax );
	mov( (type list [esi]).Tail, ebx );
	mov( (type myNode [eax]).Next, ecx );
	if
	( 
			(type myNode [eax]).i <> 15 
		&&	(type myNode [ecx]).i <> 14
		&&	(type myNode [ebx]).i <> 13
	) then
	
		stderr.put( "list.sort on three-item list failed!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
	// Test a larger list:
	
	l.destroy();
	l.create(); 
	for( mov( 0, ecx ); ecx < 16; inc( ecx )) do
	
		l.insert( n[ecx*4] );
	
	endfor;
	l.sort();
	l.numNodes();
	if( eax <> 16 ) then
	
		stderr.put( "list.sort on 16-item list should yield 16 nodes!" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	mov( 0, ecx );
	foreach l.nodeInList()do

		mov( (type myNode [esi]).i, eax );
		mov( n[ecx*4], ebx );
		if( eax <> (type myNode [ebx]).i ) then
		
			stderr.put( "list.sort on 16-item list failed!" nl );
			stderr.put( "eax=", eax, nl );
			stderr.put( "ebx=", (type myNode [ebx]).i, nl );
			stderr.put( "ecx=", ecx, nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);
		
		endif;
		inc( ecx );
		
	endfor;
	stderr.put( "virtualList_sort succeeded!" nl );
	
	
	// Test filteredNodeInList
	
	foreach l.filteredNodeInList
	( 
		thunk 
		#{ 
			xor( eax, eax );
			cmp( (type myNode [esi]).i, 10 );
			setae( al );
		}#
	) do
	
		mov( (type myNode [esi]).i, eax );
		if( eax < 10 ) then

			stderr.put( "list.filteredNodeInList failed!" nl );
			stderr.put( "eax=", eax, nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);

		endif;
		
	
	endfor; 
	stderr.put( "virtualList.filteredNodeInList succeeded!" nl );
	
	
	
	// Test filteredNodeInListReversed
	
	foreach l.filteredNodeInListReversed
	( 
		thunk 
		#{ 
			xor( eax, eax );
			cmp( (type myNode [esi]).i, 10 );
			setae( al );
		}#
	) do
	
		mov( (type myNode [esi]).i, eax );
		if( eax < 10 ) then

			stderr.put( "list.filteredNodeInListReversed failed!" nl );
			stderr.put( "eax=", eax, nl );
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);

		endif;
		
	
	endfor; 
	stderr.put( "virtualList.filteredNodeInListReversed succeeded!" nl );
	
	
	
	// Test list.search
	
	l.search
	( 
		thunk 
		#{ 
			xor( eax, eax );
			cmp( (type myNode [esi]).i, 10 );
			setae( al );
		}#
	);
	if( eax = NULL ) then


		stderr.put( "list.filteredNodeInListReversed failed!" nl );
		stderr.put( "eax=NULL" nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);

	
	endif;
	mov( (type myNode [esi]).i, eax );
	if( eax < 10 ) then

		stderr.put( "list.filteredNodeInListReversed failed!" nl );
		stderr.put( "eax=", eax, nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);

	endif;
	stderr.put( "virtualList.search succeeded!" nl );
	
	stderr.put( "virtualList_test succeeded!" nl );

end list_test;

													