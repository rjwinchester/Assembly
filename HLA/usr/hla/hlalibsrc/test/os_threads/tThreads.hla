program tThreads;
#include( "stdlib.hhf" )
#include( "threads.hhf" )
#include( "sleep.hhf" )

const
	maxThreads		:= 10;
	maxIterations	:= 10;
	
type
	tlsRecord_t:
		record
		
			threadID	:int32;
			threadNum	:uns32;
			
		endrecord;
		
static
	tlsHandle		:dword;
	mainThreadData	:tlsRecord_t;
	threadCount		:uns32;
	stdioCShandle	:dword;
	joinCShandle	:dword;
	joinEvent		:dword;
	tThreadsSema4	:dword;
	threadIDs		:uns32[maxThreads+1];

// startThread-
//
//	Prints a startup message demonstrating the use of thread local storage.

procedure startThread;
begin startThread;

	thread.enterCriticalSection( stdioCShandle );
	thread.getTLS( tlsHandle );
	stdout.put
	( 
		"Starting thread #", 
		(type tlsRecord_t [eax]).threadNum, 
		", handle=", 
		(type tlsRecord_t [eax]).threadID, 
		nl 
	);
	thread.leaveCriticalSection( stdioCShandle );

end startThread;


// getSema4-
//
//	Prints a message prior to waiting for the use of a semaphore.

procedure getSema4;
begin getSema4;

	thread.enterCriticalSection( stdioCShandle );
	thread.getTLS( tlsHandle );
	stdout.put
	( 
		"Waiting for semaphore, thread #", 
		(type tlsRecord_t [eax]).threadNum, 
		", handle=", 
		(type tlsRecord_t [eax]).threadID, 
		nl 
	);
	thread.leaveCriticalSection( stdioCShandle );

end getSema4;


// gotSema4-
//
//	Prints a message after obtaining a semaphore.

procedure gotSema4;
begin gotSema4;

	thread.enterCriticalSection( stdioCShandle );
	thread.getTLS( tlsHandle );
	stdout.put
	( 
		"Obtained semaphore, thread #", 
		(type tlsRecord_t [eax]).threadNum, 
		", handle=", 
		(type tlsRecord_t [eax]).threadID, 
		nl 
	);
	thread.leaveCriticalSection( stdioCShandle );

end gotSema4;


// releaseSema4-
//
//	Prints a message before releasing a semaphore.

procedure releaseSema4;
begin releaseSema4;

	thread.enterCriticalSection( stdioCShandle );
	thread.getTLS( tlsHandle );
	stdout.put
	( 
		"Releasing semaphore, thread #", 
		(type tlsRecord_t [eax]).threadNum, 
		", handle=", 
		(type tlsRecord_t [eax]).threadID, 
		nl 
	);
	thread.leaveCriticalSection( stdioCShandle );

end releaseSema4;


// doneWithSema4-
//
//	Prints a message before releasing a semaphore.

procedure doneWithSema4;
begin doneWithSema4;

	thread.enterCriticalSection( stdioCShandle );
	thread.getTLS( tlsHandle );
	stdout.put
	( 
		"Done using semaphore, thread #", 
		(type tlsRecord_t [eax]).threadNum, 
		", handle=", 
		(type tlsRecord_t [eax]).threadID, 
		nl 
	);
	thread.leaveCriticalSection( stdioCShandle );
	
end doneWithSema4;


// join-
//
//	Decrements threadCount and signals the "joinEvent" event when the count
// hits zero.
	
procedure join( threadNum:uns32 );
var
	threadData	:tlsRecord_t;
	
begin join;

	thread.enterCriticalSection( stdioCShandle );
	thread.getTLS(  tlsHandle );
	stdout.put
	( 
		"Thread #", 
		(type tlsRecord_t [eax]).threadNum, 
		" terminating" nl 
	);
	thread.leaveCriticalSection( stdioCShandle );
	
	thread.enterCriticalSection( joinCShandle );
	dec( threadCount );
	if( threadCount = 0 ) then
	
		thread.setEvent( joinEvent );
		
	endif;
	thread.leaveCriticalSection( joinCShandle );
	
end join;


// thread1-
//
//	Thread procedure that the various threads this test program executes.

procedure thread1( threadNum:uns32 );
var
	threadData	:tlsRecord_t;
	
begin thread1;

	try
	
		lea( eax, threadData );
		thread.setTLS( tlsHandle, eax );
		thread.getCurrentThreadHandle();
		mov( eax, threadData.threadID );
		mov( threadNum, eax );
		mov( eax, threadData.threadNum );
		startThread();
		for( mov( 0, ecx ); ecx < maxIterations; inc( ecx )) do
		
			getSema4();
			thread.waitSemaphore( tThreadsSema4 );
			gotSema4();
			
			rand.range( 100, 1000 );
			os.mSleep( eax );
			
			releaseSema4();
			thread.releaseSemaphore( tThreadsSema4 );
			doneWithSema4();
			
			rand.range( 100, 1000 );
			os.mSleep( eax );
			
		endfor;
		
	anyexception
	
		thread.enterCriticalSection( stdioCShandle );
		stdout.put
		( 
			"Thread #", 
			threadNum, 
			" ID: $",
			threadNum, 
			", thread exception: $", 
			eax, 
			nl 
		);
		thread.leaveCriticalSection( stdioCShandle );
	
	endtry;
	join( threadNum );
	
end thread1;

	
begin tThreads;

	try

		thread.getCurrentThreadHandle();
		mov( eax, threadIDs[0*4] );
		
		mov( 0, threadCount );
		
		mov( 0, mainThreadData.threadNum );
		thread.getCurrentThreadHandle();
		mov( eax, mainThreadData.threadID );
		
		thread.createTLS( tlsHandle );
		thread.setTLS( tlsHandle, &mainThreadData );
		thread.getTLS( tlsHandle );
		stdout.put( "tlsHandle=", tlsHandle, nl );
		stdout.put( "tls=", eax, nl );
		mov( &mainThreadData, eax );
		stdout.put( "main=", eax, nl );
		
		thread.createCriticalSection();
		mov( eax, stdioCShandle );
		
		thread.createCriticalSection();
		mov( eax, joinCShandle );
		
		thread.createEvent();
		mov( eax, joinEvent );
		
		thread.createSemaphore( 3, "tThreads.hla" );
		mov( eax,  tThreadsSema4 );
		
		
		thread.enterCriticalSection( joinCShandle );
		for
		( 
			mov( 0, ecx ); 
			ecx < maxThreads; 
			inc( ecx )
		) do
		
			inc( threadCount );
			lea( eax, [ecx+1] );
			thread.create( &thread1, eax, 0 );
			mov( eax, threadIDs[ ecx*4 + 4] ); 
		
		endfor;
		thread.leaveCriticalSection( joinCShandle );
		
		thread.waitForEvent( joinEvent );
		   
		thread.enterCriticalSection( stdioCShandle );
		stdout.put( "Main thread finished" nl );
		thread.leaveCriticalSection( stdioCShandle );
		   
	anyexception
		
		thread.enterCriticalSection( stdioCShandle );
		stdout.put( "Main thread exception: $", eax, nl );
		thread.leaveCriticalSection( stdioCShandle );
	
	endtry;
	thread.deleteEvent( joinEvent );
	thread.deleteCriticalSection( stdioCShandle );
	thread.deleteCriticalSection( joinCShandle );
	thread.deleteSemaphore( tThreadsSema4 );
	
	for( mov( 0, ecx ); ecx <= maxThreads; inc( ecx )) do
	
		stdout.put( "Thread: ", (type uns32 ecx), "=", threadIDs[ecx*4], nl );
		
	endfor; 
	
end tThreads;