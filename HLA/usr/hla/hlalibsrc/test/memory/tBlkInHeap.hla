// tBlockInHeap-
//
// Tests the mem.blockInHeap and mem.freeBlockInHeap iterators:

program tBlockInHeap;
#include( "stdlib.hhf" )
#include( "../../trunk/include/mem.hhf" )	
	
type
	memStat	:record
	
		totalHeapSpace	:dword;
		freeSpace		:dword;
		largestBlock	:dword;
		numBlocks		:dword;
		freeBlocks		:dword;
			
	endrecord;
	
	memalloc	:record
		adrs	:dword;
		size	:word;
		flag	:boolean;
		pad		:byte;
	endrecord;
	
static
	freeBlockCnt	:uns32;
	allocPtrs		:memalloc[4096];
	
	
	
	
	
procedure clrFlagFields;
begin clrFlagFields;

	for( mov( 0, edx ); edx < 4096; inc( edx )) do
	
		mov( false, allocPtrs.flag[edx*8] );
		
	endfor;
	
end clrFlagFields;




begin tBlockInHeap;

	// Call before any allocations. There should be no blocks
	// on the heap at this point.
	
	foreach mem.blockInHeap() do
	
		stderr.put
		(
			"tBlockInHeap: mem.blockInHeap unexpected iteration (1)" nl
		);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
	
	endfor;

	
	foreach mem.freeBlockInHeap() do
	
		stderr.put
		(
			"tBlockInHeap: mem.freeBlockInHeap iteration (2)" nl
		);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
	
	endfor;
	
	// Okay, allocate a bunch of blocks and verify them with
	// mem.blockInHeap:

	for( mov( 0, edx ); edx < 4096; inc( edx )) do
	
		rand.range( 1, 128 );
		mov( ax, allocPtrs.size[edx*8] );
		mem.alloc( eax );
		mov( eax, allocPtrs.adrs[edx*8] );
		mov( false, allocPtrs.flag[edx*8] );
		
	endfor;
	
	// Okay, verify that blockInHeap returns *exactly* the set
	// that we just allocated:
	
	mov( 0, freeBlockCnt );
	foreach mem.blockInHeap() do
	
		if( ecx <> 0 ) then	// Only check blocks not on the free list.
		
			for( mov( 0, edx ); edx < 4096; inc( edx )) do
			
				if( ebx = allocPtrs.adrs[edx*8] ) then
				
					mov( true, allocPtrs.flag[edx*8] );
					break;
					
				endif;
			
			felse
			
				stderr.put
				(
					"Error! BlockInHeap returned a pointer that wasn't allocated!" nl
					"Base address = $", ebx, nl
					"Size         = $", eax, nl
					"RefCnt       = $", ecx, nl
				);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);

			endfor;
			
		else
		
			inc( freeBlockCnt );
			
		endif;
	
	endfor;
	
	// Okay, the above for loop didn't return any (non-free) block addresses
	// that weren't present in the allocPtrs array, now we have to make sure that
	// all the allocPtrs array entries were touched:
	
	mov( true, al );
	for( mov( 0, edx ); edx < 4096; inc( edx )) do
	
		breakif( !allocPtrs.flag[edx*8] );
		
	endfor;
	if( edx <> 4096 ) then
	
		stderr.put
		(
			"Error! BlockInHeap did not return the address of some" nl
			"allocated block." nl
			"Address = $", allocPtrs.adrs[edx*8], nl
			"Size    = $", allocPtrs.size[edx*8], nl
		);
		
	endif;
	
	// Verify that we saw exactly *one* free block in the foreach loop above.
	
	if( freeBlockCnt <> 1 ) then
	
		stderr.put
		(
			"Error! BlockInHeap saw ", (type uns32 freeBlockCnt), " free blocks" nl
			"It should have seen 1 block." nl
		);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
		
	endif;
	
	
	// Okay, let's try out mem.freeBlockInHeap.
	// At this point, there should be exactly one free block in the heap.
	
	xor( edx, edx );
	foreach mem.freeBlockInHeap() do
	
		inc( edx );
		
	endfor;
	if( edx <> 1 ) then
	
		stderr.put( "Error! Expected one free block on heap, found ", edx, nl );
		
	endif;
	
	
	
	
	
	
	
	// Repeat the test for the mem.allocBlockInHeap iterator:
	
	clrFlagFields();
		
	foreach mem.allocBlockInHeap() do
	
		for( mov( 0, edx ); edx < 4096; inc( edx )) do
		
			if( ebx = allocPtrs.adrs[edx*8] ) then
			
				mov( true, allocPtrs.flag[edx*8] );
				break;
				
			endif;
		
		felse
		
			stderr.put
			(
				"Error! BlockInHeap returned a pointer that wasn't allocated!" nl
				"Base address = $", ebx, nl
				"Size         = $", eax, nl
				"RefCnt       = $", ecx, nl
			);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);

		endfor;
			
	
	endfor;
	
	// Okay, the above for loop didn't return any (non-free) block addresses
	// that weren't present in the allocPtrs array, now we have to make sure that
	// all the allocPtrs array entries were touched:
	
	mov( true, al );
	for( mov( 0, edx ); edx < 4096; inc( edx )) do
	
		breakif( !allocPtrs.flag[edx*8] );
		
	endfor;
	if( edx <> 4096 ) then
	
		stderr.put
		(
			"Error! allocBlockInHeap did not return the address of some" nl
			"allocated block." nl
			"Address = $", allocPtrs.adrs[edx*8], nl
			"Size    = $", allocPtrs.size[edx*8], nl
		);
		
	endif;
	
	
	
	// Now let's randomly free the blocks and make sure that
	// the xxxBlockInHeap functions still behave properly.
	
	mov( 1, freeBlockCnt );
	for( mov( 2, edx ); edx < 4090; add( 2, edx )) do
	
		add( 1, freeBlockCnt );
		mem.free( allocPtrs.adrs[edx*8] );
		xor( esi, esi );
		foreach mem.freeBlockInHeap() do
		
			inc( esi );
			
		endfor;
		if( esi <> freeBlockCnt ) then
		
			stderr.put
			(
				"Error! freeBlockInHeap has wrong value after mem.free(1)" nl
				"EDX = $", edx, nl
			);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
			
		endif;
	
	endfor;
		
	
	// The following calls to mem.free should actually *reduce* the
	// number of free blocks, as mem.free should coalese three blocks
	// (two free plus one allocated) into a single block.
	
	for( mov( 3, edx ); edx < 4089; add( 2, edx )) do
	
		sub( 1, freeBlockCnt );
		mem.free( allocPtrs.adrs[edx*8] );
		xor( esi, esi );
		foreach mem.freeBlockInHeap() do
		
			inc( esi );
			
		endfor;
		if( esi <> freeBlockCnt ) then
		
			stderr.put
			(
				"Error! freeBlockInHeap has wrong value after mem.free(2)" nl
				"EDX          = $", edx, nl
				"ESI          = ", (type uns32 esi), nl
				"freeBlockCnt = ", freeBlockCnt, nl
			);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
			
		endif;
	
	endfor;	
	
	
	
	stderr.put( "tBlockInHeap succeeded!" nl );
	
	
end tBlockInHeap;	