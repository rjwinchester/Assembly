// tMemUtils-
//
// Tests the realloc, realloc2, and zalloc functions:


program tReZalloc;
#include( "stdlib.hhf" )
#include( "../../trunk/include/mem.hhf" )	

const
	listSize	:= 1024;
	
type
	memalloc	:record
		adrs	:dword;
		size	:uns32;
	endrecord;
	
static
	blk				:dword;
	allocPtrs		:memalloc[listSize];
	

procedure initialize( index:dword in edx );
begin initialize;

	mov( allocPtrs.adrs[edx*8], edi );
	mov( allocPtrs.size[edx*8], ecx );
	while( ecx > 0 ) do
	
		rand.range( 1, 255 );
		mov( al, [edi] );
		inc( edi );
		dec( ecx );
		
	endwhile;
	
end initialize;


procedure testRealloc( index:dword; newsize:dword );
var
	localPtr	:dword;
	oldSize		:dword;
	edxSave		:dword;
	
begin testRealloc;

	mov( edx, edxSave );
	
	// Make a local copy of the data so we can compare it
	// after the reallocation operation:
	
	mov( index, edx );
	mov( allocPtrs.size[edx*8], ecx );
	mov( ecx, oldSize );
	mem.talloc( ecx );
	mov( eax, localPtr );
	
	mov( eax, edi );
	mov( allocPtrs.adrs[edx*8], esi );
	rep.movsb();
	
	// Okay, do a reallocation:
	
	mem.realloc( allocPtrs.adrs[edx*8], newsize );
	mov( eax, allocPtrs.adrs[edx*8] );		// ptr may have changed!
	
	// Now compare the new data block against the old data block,
	// up to the size of the shorter of the two blocks.
	
	mov( newsize, ecx );
	cmp( ecx, oldSize );
	cmova( oldSize, ecx );
	mov( localPtr, esi );
	mov( allocPtrs.adrs[edx*8], edi );
	repe.cmpsb();
	if( @nz ) then
	
		stderr.put
		(
			"After realloc, blocks (to size of smaller) do not match" nl
		);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
		
	endif;
	mov( edxSave, edx );
	
end testRealloc;	
	



procedure testRealloc2( index:dword; newSize:dword );
var
	localPtr	:dword;
	oldSize		:dword;
	edxSave		:dword;
	
begin testRealloc2;

	mov( edx, edxSave );
	
	// Make a local copy of the data so we can compare it
	// after the reallocation operation:
	
	mov( index, edx );
	mov( allocPtrs.size[edx*8], ecx );
	mov( ecx, oldSize );
	mem.talloc( ecx );
	mov( eax, localPtr );
	
	mov( eax, edi );
	mov( allocPtrs.adrs[edx*8], esi );
	rep.movsb();
	
	// Okay, do a reallocation:
	
	mem.realloc2
	( 
		allocPtrs.adrs[edx*8], 
		newSize,
		thunk 
		#{
			rep.movsb();
		}# 
	);
	mov( eax, allocPtrs.adrs[edx*8] );		// ptr may have changed!
	
	// Now compare the new data block against the old data block,
	// up to the size of the shorter of the two blocks.
	
	mov( newSize, ecx );
	cmp( ecx, oldSize );
	cmova( oldSize, ecx );
	mov( localPtr, esi );
	mov( allocPtrs.adrs[edx*8], edi );
	repe.cmpsb();
	if( @nz ) then
	
		stderr.put
		(
			"After realloc2, blocks (to size of smaller) do not match" nl
		);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
		
	endif;
	mov( edxSave, edx );
	
end testRealloc2;	
	

begin tReZalloc;

	// First, allocate a really large block and initialize it with
	// $FF bytes so we can test zalloc:
	
	mem.alloc( 1024*1024 - 64 );
	mov( eax, edi );
	mov( eax, blk );
	mov( 512*1024 div 4, ecx );
	mov( -1, eax );
	rep.stosd();
	
	// Free the above storage. This leaves $FFs throughout the heap
	
	mem.free( blk );
	
	// Okay, do a bunch of zallocs:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		rand.range( 1, 1024 );
		mov( eax, allocPtrs.size[ edx*8 ]);
		mem.zalloc( eax );
		mov( eax, allocPtrs.adrs[ edx*8 ]);
		
		mov( eax, edi );
		mov( allocPtrs.size[ edx*8 ], ecx );
		xor( eax, eax );
		repe.scasb();
		if( @nz ) then
		
			stderr.put
			(
				"zalloc created an allocation that contained a non-zero value(1)!" nl
				"ECX = ", (type uns32 ecx), nl
				"size = ", allocPtrs.size[ edx*8 ], nl
			);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
			
		endif;
		
	endfor; 
	
	// Make another pass, to be sure that one allocation didn't wipe out another:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		mov( allocPtrs.adrs[ edx*8 ], edi );
		mov( allocPtrs.size[ edx*8 ], ecx );
		xor( eax, eax );
		repe.scasb();
		if( @nz ) then
		
			stderr.put
			(
				"zalloc created an allocation that contained a non-zero value(1)!" nl
				"ECX = ", (type uns32 ecx), nl
				"size = ", allocPtrs.size[ edx*8 ], nl
			);
stdout.put( "Press Enter to Continue: " );
stdin.readLn();
os.exitProcess(1);
			
		endif;
		
	endfor;

	/////////   R E A L L O C    T E S T S   ///////////////////////////////
	//
	// Go through and free all the blocks:
	
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		mem.free( allocPtrs.adrs[edx*8] );
		
	endfor;
	
	// Now allocate a series of fixed-sized blocks:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		mem.zalloc( 256 );
		mov( eax, allocPtrs.adrs[edx*8] );
		mov( 256, allocPtrs.size[edx*8] );
		initialize( edx );
		
	endfor;
	
	// Call realloc to make all the blocks larger:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc( edx, 512 );	
				
	endfor;	
	 
	// Call realloc to make all the blocks smaller:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc( edx, 256 );	
				
	endfor;
	
	// Make them larger again, to reuse the space just freed up
		
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc( edx, 512 );	
				
	endfor;	
	 
	// Make them smaller again. 
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc( edx, 256 );	
				
	endfor;
	
	// Make them larger, but this time we don't get to use the free space
		
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc( edx, 4096 );	
				
	endfor;	
	
	// Go through and do random sizes:
	
		
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		rand.range( 1, 8192 );
		testRealloc( edx, eax );	
				
	endfor;	
	 
	 
	
	/////////   R E A L L O C 2    T E S T S   ///////////////////////////////
	//
	// Go through and free all the blocks:
	
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		mem.free( allocPtrs.adrs[edx*8] );
		
	endfor;
	
	// Now allocate a series of fixed-sized blocks:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		mem.zalloc( 256 );
		mov( eax, allocPtrs.adrs[edx*8] );
		mov( 256, allocPtrs.size[edx*8] );
		initialize( edx );
		
	endfor;
	
	// Call realloc2 to make all the blocks larger:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc2( edx, 512 );	
				
	endfor;	
	 
	// Call realloc to make all the blocks smaller:
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc2( edx, 256 );	
				
	endfor;
	
	// Make them larger again, to reuse the space just freed up
		
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc2( edx, 512 );	
				
	endfor;	
	 
	// Make them smaller again. 
	
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc2( edx, 256 );	
				
	endfor;
	
	// Make them larger, but this time we don't get to use the free space
		
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		testRealloc2( edx, 4096 );	
				
	endfor;	
	
	// Go through and do random sizes:
	
		
	for( mov( 0, edx ); edx < listSize; inc( edx )) do
	
		rand.range( 1, 8192 );
		testRealloc2( edx, eax );	
				
	endfor;	
	 
	 
	
	stderr.put( "tReZalloc succeeded!" nl );
	
	
end tReZalloc;	