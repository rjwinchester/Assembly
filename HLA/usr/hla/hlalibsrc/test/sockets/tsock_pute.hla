program spute_test; 
#include( "stdlib.hhf" )
#includeOnce( "sockets.hhf" )
#includeOnce( "sleep.hhf" )

static
	quit		:dword := 0;
	hostIPadrs	:dword;
	s			:server_t;
	timeout		:thunk;
	calls		:dword := 0;
	
	ipAdrsStr	:str.strvar(256);
	cmdLine		:str.strvar(256);
	exmsg		:str.strvar(256);
	
	e32			:real32 := 0.0;
	e64			:real64 := 0.0;
	e80			:real80 := 0.0;
	
	e32a		:real32 := 1.0;
	e64a		:real64 := 1.0;
	e80a		:real80 := 1.0;
	
	e32b		:real32 := 1.0e-37;
	e64b		:real64 := 1.0e-307;
	e80b		:real80 := 1.0e-4094;
	
	e32pi		:real32;
	e64pi		:real64;
	e80pi		:real80;

	bad_a		:real64 := 1.0e-272;
	bad_b		:real64 := 1.0e-256;
	
	
	procedure connected;
		@nodisplay;
		@nostackalign;
		@noframe;
	var
		handle		:dword;
		bufIndex	:dword;
		object		:pointer to server_t;
		ipAdrs		:hla.sockaddr;
		
		buffer		:char[64];
		
	begin connected;

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		pushad();
		pushfd();
		
		mov( eax, handle );
		mov( esi, object );
		
		/*****************************************************************/
		

		object.puts( "Outputting zeros:" nl nl );
		object.pute32( e32, 13 );
		object.newln();

		object.pute64( e64, 15 );
		object.newln();

		object.pute80( e80, 20 );
		object.newln();
		object.newln();
		object.newln();

		object.puts( "Real32 Powers of Ten: " nl nl );
		for( mov( -37, ecx ); (type int32 ecx) < 0; inc( ecx )) do

			object.pute32( e32b, 11 );
			object.newln();

			fld( e32b );
			fld( 10.0 );
			fmulp();
			fstp( e32b );

		endfor;
		fld1();
		fstp( e32b );
		for( mov( 0, ecx ); ecx < 38; inc( ecx )) do

			object.pute32( e32b, 11 );
			object.newln();

			fld( e32b );
			fld( 10.0 );
			fmulp();
			fstp( e32b );

		endfor;
		object.newln();
		object.newln();
		object.newln();


		object.puts( "Real64 Powers of Ten: " nl nl );
		for( mov( -307, ecx ); (type int32 ecx) < 0; inc( ecx )) do

			object.pute64( e64b, 15 );
			object.newln();

			fld( e64b );
			fld( 10.0 );
			fmulp();
			fstp( e64b );

		endfor;
		fld1();
		fstp( e64b );
		for( mov( 0, ecx ); ecx < 308; inc( ecx )) do

			object.pute64( e64b, 15 );
			object.newln();

			fld( e64b );
			fld( 10.0 );
			fmulp();
			fstp( e64b );

		endfor;
		object.newln();
		object.newln();
		object.newln();


		object.puts( "Real80 Powers of Ten: " nl nl );
		for( mov( -4094, ecx ); (type int32 ecx) < 0; inc( ecx )) do

			object.pute80( e80b, 20 );
			object.newln();

			fld( e80b );
			fld( 10.0 );
			fmulp();
			fstp( e80b );

		endfor;

		fld1();
		fstp( e80b );
		for( mov( 0, ecx ); ecx <= 4095; inc( ecx )) do

			object.pute80( e80b, 20 );
			object.newln();

			fld( e80b );
			fld( 10.0 );
			fmulp();
			fstp( e80b );

		endfor;
		object.newln();
		object.newln();
		object.newln();


		object.puts( "Real32 Powers of Two: " nl nl );
		for( mov( 0, ecx ); ecx < 127; inc( ecx )) do

			object.pute32( e32a, 11 );
			object.newln();

			fld( e32a );
			fld( 2.0 );
			fmulp();
			fstp( e32a );

		endfor;
		object.newln();
		object.newln();
		object.newln();

		object.puts( "Real64 Powers of Two: " nl nl );
		for( mov( 0, ecx ); ecx < 1023; inc( ecx )) do

			object.pute64( e64a, 15 );
			object.newln();

			fld( e64a );
			fld( 2.0 );
			fmulp();
			fstp( e64a );

		endfor;
		object.newln();
		object.newln();
		object.newln();



		object.puts( "Real80 Powers of Two: " nl nl );
		for( mov( 0, ecx ); ecx < 16383; inc( ecx )) do

			object.pute80( e80a, 18 );
			object.newln();

			fld( e80a );
			fld( 2.0 );
			fmulp();
			fstp( e80a );

		endfor;
		object.newln();
		object.newln();
		object.newln();




		fldpi();
		fstp( e32pi );
		fldpi();
		fstp( e64pi );
		fldpi();
		fstp( e80pi );

		object.puts( "Multiples of PI: " nl nl );
		for( mov( 0, ecx ); ecx < 32; inc( ecx )) do

			object.pute32( e32pi, 11 );
			object.newln();

			object.pute64( e64pi, 15 );
			object.newln();

			object.pute80( e80pi, 20 );
			object.newln();

			fld( e32pi );
			fldpi();
			fmulp();
			fstp( e32pi );

			fld( e64pi );
			fldpi();
			fmulp();
			fstp( e64pi );

			fld( e80pi );
			fldpi();
			fmulp();
			fstp( e80pi );

		endfor;
		object.newln();
		object.newln();
		object.newln();



		object.puts( "Divisions by PI: " nl nl );
		for( mov( 0, ecx ); ecx < 32; inc( ecx )) do

			object.pute32( e32pi, 11 );
			object.newln();

			object.pute64( e64pi, 15 );
			object.newln();

			object.pute80( e80pi, 20 );
			object.newln();

			fld( e32pi );
			fldpi();
			fdivp();
			fstp( e32pi );

			fld( e64pi );
			fldpi();
			fdivp();
			fstp( e64pi );

			fld( e80pi );
			fldpi();
			fdivp();
			fstp( e80pi );

		endfor;

		object.pute32( e32pi, 11 );
		object.newln();

		object.pute64( e64pi, 15 );
		object.newln();

		object.pute80( e80pi, 20 );
		object.newln();
				
		/*****************************************************************/
		
		object.close();
		mov( 1, quit );
		popfd();
		popad();
		leave();
		ret( _parms_ );
		
	end connected;
	
begin spute_test; 

	thunk timeout :=
		#{
			// On entry to thunk, EAX contains the address of the timeout
			// variable. Set this as desired for the timeout (1 second,
			// in this case).
			
			mov( 1, (type hla.timeval [eax]).tv_sec );
			stderr.put( "server", nl );
			
			// On the second call to this thunk, start the client application:
			
			cmp( calls, 1 );
			jne dontRunApp;
			
				str.put
				(
					cmdLine,
					"wclient.exe socket_pute.txt ",
					ipAdrsStr,
					" 888a"
				);
				stdout.put( "cmd=", cmdLine, "'" nl );
				os.bkgnd( cmdLine );
			
			dontRunApp:
			inc( calls );
			mov( quit, eax );
				
		}#;
	
	try
	
		s.create();
		
		sock.hostAdrs(); 
		mov( eax, hostIPadrs );
		sock.ipToStr( eax, ipAdrsStr );
		
		s.start
		( 
			hostIPadrs, 
			$888a, 
			timeout,
			&connected,
			0
		);
		
	  anyexception
	  
	  	ex.exceptionMsg( eax, exmsg );
	  	stdout.put( "Server Exception: ", exmsg, nl );
		fileio.close( s.handle );
		s.destroy();
		
	endtry;
	while( !filesys.exists( "wclient.done" )) do
	
		os.sleep( 1 );
		
	endwhile;
	os.sleep( 1 );
	filesys.delete( "wclient.done" );
	 
end spute_test; 
