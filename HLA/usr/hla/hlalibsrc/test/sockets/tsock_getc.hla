program sagetc_test; 
#include( "stdlib.hhf" )
#include( "sockets.hhf" )

const
	bufData_c : char[] :=
				[
					'a', #$d, #$a,
					'b', 'c',  #$d, #$a,
					'd', ' ', 'e', 'f', #$d, #$a,
					#$d, #$a,
					'1', '0', '0', #$d, #$a
				];
	

	
readonly
	bufData		:char[ @elements( bufData_c )] := bufData_c;
	
static
	quit		:dword := 0;
	hostIPadrs	:dword;
	s			:server_t;
	timeout		:thunk;
	calls		:dword := 0;
	
	ipAdrsStr	:str.strvar(256);
	cmdLine		:str.strvar(256);
	exmsg		:str.strvar(256);
	
	
	
	procedure connected;
		@nodisplay;
		@nostackalign;
		@noframe;
	var
		handle		:dword;
		bufIndex	:dword;
		object		:pointer to server_t;
		ipAdrs		:hla.sockaddr;
		
	begin connected;

		push( ebp );
		mov( esp, ebp );
		sub( _vars_, esp );
		
		pushad();
		pushfd();
		
		mov( eax, handle );
		mov( esi, object );
		
		try
		
			mov( 0, bufIndex );
			forever
			
				object.getc( );
				mov( bufIndex, ebx );
				cmp( al, bufData[ebx] );
				if( @ne ) then
				
					stderr.put
					( 
						"socket.getc did not match input file at index ",
						(type uns32 ebx), 
						nl
					);
					stdout.put( "Press Enter to Continue: " );
					stdin.readLn();
					stdout.put( "Press Enter to Continue: " );
					stdin.readLn();
					os.exitProcess(1);
					
				endif;
				inc( bufIndex );
				
			endfor;
			
		  exception( ex.EndOfFile )
		  
			cld();
			mov( bufIndex, ecx );
			if( ecx <> @elements( bufData_c )) then
			
				stderr.put( "socket.getc read the wrong # of chars" nl );
				os.exitProcess( 2 );
				
			endif;
			stderr.put( "socket.getc succeeded!" nl );
			
		  anyexception

			stderr.put
			( 
				nl nl 
				"***************************************************" nl
				"socket.getc failed!" nl
				"Data read did not match data expected in file" nl
				"***************************************************" nl
				nl 
			);
			os.exitProcess(3);
			
		endtry;
		
		object.close();
		mov( 1, quit );
		popfd();
		popad();
		leave();
		ret( _parms_ );
		
	end connected;
	
begin sagetc_test; 

	thunk timeout :=
		#{
			// On entry to thunk, EAX contains the address of the timeout
			// variable. Set this as desired for the timeout (4 seconds,
			// in this case).
			
			mov( 4, (type hla.timeval [eax]).tv_sec );
			stderr.put( "server", nl );
			
			// On the second call to this thunk, start the client application:
			
			cmp( calls, 1 );
			jne dontRunApp;
			
				#if( os.win32 )
				
					str.put
					(
						cmdLine,
						"cmd /C rclient socket_getc.wdata ",
						ipAdrsStr,
						" 8808"
					);
					stdout.put( "cmd=", cmdLine, "'" nl );
					
				#else
				
					str.put
					(
						cmdLine,
						"rclient.exe socket_getc.wdata ",
						ipAdrsStr,
						" 8808"
					);
					stdout.put( "cmd=", cmdLine, "'" nl );
					
				#endif
				os.bkgnd( cmdLine );
			
			dontRunApp:
			inc( calls );
			mov( quit, eax );
				
		}#;
	
	try
	
		s.create();
		
		sock.hostAdrs(); 
		mov( eax, hostIPadrs );
		sock.ipToStr( eax, ipAdrsStr );
		
		s.start
		( 
			hostIPadrs, 
			$8808, 
			timeout,
			&connected,
			0
		);
		
	  anyexception
	  
	  	ex.exceptionMsg( eax, exmsg );
	  	stdout.put( "Server Exception: ", exmsg, nl );
		fileio.close( s.handle );
		s.destroy();
		
	endtry;
	 
end sagetc_test; 
