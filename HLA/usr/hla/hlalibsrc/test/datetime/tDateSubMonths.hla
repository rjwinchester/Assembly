program subMonths_test;
#include( "stdlib.hhf" )

static
	baseDate	:date.daterec;
	decDate		:date.daterec;
	subDate		:date.daterec;
	ovflDate	:date.daterec;
	
	altDate		:date.daterec;
	endDate		:date.daterec;
	
	months		:dword;
	
	overflow	:dword[13] :=
				[ 	0, 	// Jan->Dec
					0,	// Feb->Jan
					3,	// Mar->Feb (non-leap year)
					0,	// Apr->Mar
					1,	// May->Apr
					0,	// June->May
					1,	// July->June
					0,	// Aug->July
					0,	// Sep->Aug
					1,	// Oct->Sep
					0,	// Nov->Oct
					1,	// Dec->Nov
					0	// Unused
				]; 
	
begin subMonths_test;

	 
	date.setFormat( date.mmddyyyy );
	
	date.pack( 12, 1, date.maxYear-1, baseDate );
	mov( (type dword baseDate), eax );
	mov( eax, (type dword decDate));
	mov( eax, (type dword subDate));
	mov( eax, (type dword altDate));
	date.pack( 2, 1, date.minYear, endDate );
	
	
	mov( 0, months );
	while( mov( endDate, eax ) < (type dword altDate) ) do
	
		inc( months );
		mov( baseDate, eax );
		mov( eax, subDate );
		mov( decDate, eax );
		mov( eax, ovflDate );
		xor( ecx, ecx );
		date.subMonths( months, subDate );
		cmp( eax, ecx );
		jnz badOverflow; 
		date.subMonths( 1, decDate );
		cmp( eax, ecx );
		jnz badOverflow; 
		
		// The following tests overflow return values
		// from date.subMonths. It sets the date to the
		// last day of the month, subtracts a month,
		// and then checks the return value in EAX
		// to verify that it contains a proper number
		// of overflow days.
		//
		// Set ovflDate to the end of the month.
		
		movzx( ovflDate.month, edx );
		xor( edi, edi );
		mov( overflow[edx*4-4], ecx );
		mov( date.DaysInMonth[edx*4], edx );
		date.isLeapYear( ovflDate.year );
		if( ovflDate.month = 2 ) then	// For Feb, last day is 28 or 29
		
			add( eax, edx );
			
		endif;
		mov( dl, ovflDate.day );

		// Compute the number of expected overflow days:
		
		if( ovflDate.month = 3 ) then // Mar->Feb transition
		
			mov( eax, edi );
		
		endif;
		sub( edi, ecx );	// Adjust expected overflow for leap years
		
		// Subtract a month and see if the number of overflow
		// days is proper.
		
		date.subMonths( 1, ovflDate );
		cmp( eax, ecx );
		jne badOverflow;
		
		// Adjust the dates for the next iteration.
		
		dec( altDate.month );
		if( altDate.month = 0 ) then
			
			mov( 12, altDate.month );
			dec( altDate.year );
			
		endif;
		mov( subDate, eax );
		mov( decDate, ebx );
		mov( altDate, ecx );
		cmp( eax, ebx );
		jne badDate;
		cmp( eax, ecx );
		jne badDate;
		
	endwhile;
	stderr.put( "date.subMonths succeeded!" nl );
	os.exitProcess(0);

badDate:
	date.a_toString( decDate );
	stderr.put
	( 
		nl nl 
		"***************************************************" nl
		"date.subMonths failed!", nl,
		"decDate= '",
		(type string eax), "'" nl
	);
	str.free( eax );
	date.a_toString( subDate );
	stderr.put
	(
		"subDate= '",
		(type string eax), "'" nl
	);
	str.free( eax );
	date.a_toString( altDate );
	stderr.put
	(
		"altDate= '", (type string eax), "'" nl
		"***************************************************" nl
		nl 
	);
	str.free( eax );
	stdout.put( "Press Enter to Continue: " );
	stdin.readLn();
	os.exitProcess(1);
		
badOverflow:
	mov( eax, edx );
	date.a_toString( decDate );
	stderr.put
	( 
		nl nl 
		"***************************************************" nl
		"date.subMonths failed!", nl,
		"Overflow was ", 
		(type int32 edx), 
		" should be ",
		(type int32 ecx),
		nl
		"decDate= '",
		(type string eax), "'" nl
	);
	str.free( eax );
	date.a_toString( subDate );
	stderr.put
	(
		"subDate= '",
		(type string eax), "'" nl
	);
	str.free( eax );
	date.a_toString( altDate );
	stderr.put
	(
		"altDate= '", (type string eax), "'" nl
	);
	str.free( eax );
	date.a_toString( ovflDate );
	stderr.put
	(
		"ovflDate= '", (type string eax), "'" nl
		"***************************************************" nl
		nl 
	);
	str.free( eax );
	stdout.put( "Press Enter to Continue: " );
	stdin.readLn();
	os.exitProcess(1);
		
end subMonths_test;

													