program addSecs_test;
#include( "stdlib.hhf" )

static
	baseTime	:time.timerec;
	sumTime		:timeClass;
	baseSeconds	:dword;
	seconds		:dword;
	_ebx		:uns32;	
	
begin addSecs_test;
	
	mov( 0, baseTime );
	mov( 0, baseSeconds );
	sumTime.create();
	repeat
			
		for( mov( 0, ebx ); ebx <= 60*60*24; inc( ebx )) do
		
			mov( ebx, _ebx );
			mov( baseTime, eax );
			mov( eax, sumTime.theTime );			
			try
			
				mov( ebx, eax );
				add( baseSeconds, eax );
				mov( eax, seconds );
				
				// addSecs returns day overflow in EAX:
				
				sumTime.addSecs( ebx );
				
				// Compute the number of expected day overflows
				// in ECX (0..2):
				
				movzx( baseTime.hours, ecx );	// Convert base time to seconds
				intmul( 60, ecx );
				movzx( baseTime.mins, esi );
				add( esi, ecx );
				intmul( 60, ecx );
				movzx( baseTime.secs, esi );
				add( esi, ecx );
				
				add( ebx, ecx );				// Add in current seconds
				if( ecx < 24*60*60 ) then		// and calculate day overflow.
				
					mov( 0, ecx );
					
				elseif( ecx < 48*60*60 ) then
				
					mov( 1, ecx );
					
				elseif( ecx < 72*60*60 ) then
				
					mov( 2, ecx );
					
				else
				
					lea( ecx, [eax+1] ); // Guarantee mismatch
				
				endif;
				
				// Error if the number of overflow days
				// does not match.
				
				cmp( eax, ecx );
				jne timeaddSecsFailed1;
				
				// Convert to seconds and verify
				// against our incrementing seconds value:
				
				sumTime.toSecs();
				intmul( 60*60*24, ecx );	// Seconds in overflow days.
				add( ecx, eax );			// Seconds plus overflow days.
				cmp( eax, seconds );
				jne timeaddSecsFailed2;
				
			  anyexception
			  
			  	jmp timeaddSecsFailed3;
			  					
			endtry;
				
		endfor;
		
		// Skip over lots of seconds on each loop because
		// this test takes way too long (don't worry, we're
		// checking all possible additions up to two days
		// because of the for loop above).
		
		add( 10, baseSeconds );
		add( 10, baseTime.secs );
		xor( eax, eax );
		if( baseTime.secs >= 60 ) then
		
			mov( 0, baseTime.secs );
			add( 2*60, baseSeconds );
			add( 3, baseTime.mins );
			if( baseTime.mins >= 60 ) then
			
				mov( 0, baseTime.mins );
				add( 2, baseTime.hours );
				add( 60*60, baseSeconds );
				if( baseTime.hours >= 24 ) then
				
					mov( 1, eax );
					
				endif;
				
			endif;
			
		endif;
		
	until( eax <> 0 );
	stderr.put( "time.addSecs succeeded!" nl );
	os.exitProcess(0);
	
timeaddSecsFailed3:
	mov( 3, bl );
	jmp timeaddSecsFailed;
	
timeaddSecsFailed2:
	mov( 2, bl );
	jmp timeaddSecsFailed;
	
timeaddSecsFailed1:
	mov( 1, bl );
timeaddSecsFailed:
	stderr.put
	( 
		nl nl 
		"***************************************************" 
		nl
		"time.addSecs failed! (", (type uns8 bl), ")", nl,
		"Time= ",
		(type uns8 baseTime.hours),
		":",
		(type uns8 baseTime.mins),
		":",
		(type uns16 baseTime.secs ),
		"+",
		_ebx,
		" Seconds = ", (type uns32 eax), " should be ", (type uns32 seconds),
		nl
	);
	stdout.put( "Press Enter to Continue: " );
	stdin.readLn();
	os.exitProcess(1);
							
end addSecs_test;

													