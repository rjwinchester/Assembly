// tLogical-
//
//	Tests the following MATH module functions:
//
//	 andq, andl, notq, notl, orq, orl, shlq, shll, xorq, and xorl.


program tLogical;
#include( "stdlib.hhf" )

val
	
	pwrsOf2_64_c	:uns64[] :=
		[
			#for( i := 0 to 63 )
				1 << i,
			#endfor
		];
	
		
	pwrsOf2m1_64_c	:uns64[] :=
		[
			#for( i := 0 to 63 )
				(1 << i)-1,
			#endfor
		];
	
	?sresult := 0;
	altBits_64_c	:uns64[] :=
		[
			#for( i := 0 to 31 )
				?sresult := (sresult << 2) | 1;
				sresult,
			#endfor
		];
		
	?sresult := 0;
	altBits2_64_c	:uns64[] :=
		[
			#for( i := 0 to 31 )
				?sresult := (sresult << 2) | 2;
				sresult,
			#endfor
		];
	
	
	
	
	notPwrsOf2_64_c	:uns64[] :=
		[
			#for( i := 0 to 63 )
				@uns64(!( 1 << i )),
			#endfor
		];
	
		
	notPwrsOf2m1_64_c	:uns64[] :=
		[
			#for( i := 0 to 63 )
				@uns64(!((1 << i)-1)),
			#endfor
		];
	
	?sresult := 0;
	notAltBits_64_c	:uns64[] :=
		[
			#for( i := 0 to 31 )
				?sresult := (sresult << 2) | 1;
				@uns64(!sresult),
			#endfor
		];
		
	?sresult := 0;
	notAltBits2_64_c	:uns64[] :=
		[
			#for( i := 0 to 31 )
				?sresult := (sresult << 2) | 2;
				@uns64(!sresult),
			#endfor
		];
	
	?sresult := 0;
	pairBits_64_c	:uns64[] :=
		[
			#for( i := 0 to 31 )
				?sresult := (sresult << 2) | 3;
				sresult,
			#endfor
		];
	
	
	
	
		
	
	pwrsOf2_128_c	:uns128[] :=
		[
			#for( i := 0 to 127 )
				1 << i,
			#endfor
		];
	
	pwrsOf2m1_128_c	:uns128[] :=
		[
			#for( i := 0 to 127 )
				(1 << i)-1,
			#endfor
		];
	
	?sresult := 0;
	altBits_128_c	:uns128[] :=
		[
			#for( i := 0 to 63 )
				?sresult := (sresult << 2) | 1;
				sresult,
			#endfor
		];
		
	?sresult := 0;
	altBits2_128_c	:uns128[] :=
		[
			#for( i := 0 to 63 )
				?sresult := (sresult << 2) | 2;
				sresult,
			#endfor
		];
		
		
	
	notPwrsOf2_128_c	:uns128[] :=
		[
			#for( i := 0 to 127 )
				@uns128(!(1 << i)),
			#endfor
		];
	
	notPwrsOf2m1_128_c	:uns128[] :=
		[
			#for( i := 0 to 127 )
				@uns128(!((1 << i)-1)),
			#endfor
		];
	
	?sresult := 0;
	notAltBits_128_c	:uns128[] :=
		[
			#for( i := 0 to 63 )
				?sresult := (sresult << 2) | 1;
				@uns128(!sresult),
			#endfor
		];
		
	?sresult := 0;
	notAltBits2_128_c	:uns128[] :=
		[
			#for( i := 0 to 63 )
				?sresult := (sresult << 2) | 2;
				@uns128(!sresult),
			#endfor
		];
		
	
	?sresult := 0;
	pairBits_128_c	:uns128[] :=
		[
			#for( i := 0 to 63 )
				?sresult := (sresult << 2) | 3;
				sresult,
			#endfor
		];
		
		
	
	
static
	u64				:uns64;
	u64a			:uns64;
	result64		:uns64;
	result64a		:uns64;
		
	u128			:uns128;
	result128		:uns128;
	u128a			:uns128;
	result128a		:uns128;
	
readonly
	
	allOnes64		:uns64 := $FFFF_FFFF_FFFF_FFFF;
	pwrsOf2_64		:uns64[ @elements( pwrsOf2_64_c ) ] := pwrsOf2_64_c;
	pwrsOf2m1_64	:uns64[ @elements( pwrsOf2m1_64_c ) ] := pwrsOf2m1_64_c;
	altBits_64		:uns64[ @elements( altBits_64_c ) ] := altBits_64_c;
	altBits2_64		:uns64[ @elements( altBits2_64_c ) ] := altBits2_64_c;
	
	allOnes128		:uns128 := $FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF;
	pwrsOf2_128		:uns128[ @elements( pwrsOf2_128_c ) ] := pwrsOf2_128_c;
	pwrsOf2m1_128	:uns128[ @elements( pwrsOf2m1_128_c ) ] := pwrsOf2m1_128_c;
	altBits_128		:uns128[ @elements( altBits_128_c ) ] := altBits_128_c;
	altBits2_128	:uns128[ @elements( altBits2_128_c ) ] := altBits2_128_c;
	
	notPwrsOf2_64		:uns64[ @elements( notPwrsOf2_64_c ) ] := notPwrsOf2_64_c;
	notPwrsOf2m1_64		:uns64[ @elements( notPwrsOf2m1_64_c ) ] := notPwrsOf2m1_64_c;
	notAltBits_64		:uns64[ @elements( notAltBits_64_c ) ] := notAltBits_64_c;
	notAltBits2_64		:uns64[ @elements( notAltBits2_64_c ) ] := notAltBits2_64_c;
	
	notPwrsOf2_128		:uns128[ @elements( notPwrsOf2_128_c ) ] := notPwrsOf2_128_c;
	notPwrsOf2m1_128	:uns128[ @elements( notPwrsOf2m1_128_c ) ] := notPwrsOf2m1_128_c;
	notAltBits_128		:uns128[ @elements( notAltBits_128_c ) ] := notAltBits_128_c;
	notAltBits2_128		:uns128[ @elements( notAltBits2_128_c ) ] := notAltBits2_128_c;
	
	pairBits_64		:uns64[ @elements( pairBits_64_c ) ] := pairBits_64_c;
	pairBits_128	:uns128[ @elements( pairBits_128_c ) ] := pairBits_128_c;
	
	
procedure cmp64( index:uns32; testVal1:qword; testVal2:qword; msg:string );
begin cmp64;

	push( edx );
	mov( (type dword testVal1), eax );
	mov( (type dword testVal1[4]), edx );
	cmp( eax, (type dword testVal2));
	jne failed;
	cmp( edx, (type dword testVal2[4]));
	je succeeded;
	failed:
	
		stderr.put
		( 
			"Error: ", msg, nl
			"testVal1: ", testVal1, nl
			"testVal2: ", testVal2, nl
		);
		conv.setUnderscores( true );
		stderr.put
		(
			"index:    ", index, nl 
		);
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	succeeded:
	pop( edx );
	
end cmp64;

	
procedure cmp128( index:uns32; testVal1:lword; testVal2:lword; msg:string );
begin cmp128;

	mov( (type dword testVal1), eax );
	cmp( eax, (type dword testVal2));
	jne failed;
	mov( (type dword testVal1[4]), eax );
	cmp( eax, (type dword testVal2[4]));
	jne failed;
	mov( (type dword testVal1[8]), eax );
	cmp( eax, (type dword testVal2[8]));
	jne failed;
	mov( (type dword testVal1[12]), eax );
	cmp( eax, (type dword testVal2[12]));
	je succeeded;
	failed:
	
		stderr.put
		( 
			"Error: ", msg, nl
			"testVal1: ", testVal1, nl
			"testVal2: ", testVal2, nl
		);
		conv.setUnderscores( true );
		stderr.put
		(
			"index:    ", index, nl 
		);
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	succeeded:
	
end cmp128;

begin tLogical;
	
	// ANDQ tests:
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.andq( pwrsOf2_64[edx*8], pwrsOf2_64[edx*8], result64 );
		cmp64( edx, result64, pwrsOf2_64[ edx*8 ], "andq(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.andq( pwrsOf2_64[edx*8], allOnes64, result64 );
		cmp64( edx, result64, pwrsOf2_64[ edx*8 ], "andq(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.andq( pwrsOf2_64[edx*8], 0, result64 );
		cmp64( edx, result64, 0, "andq(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		math.andq( altBits_64[edx*8], altBits2_64[edx*8], result64 );
		cmp64( edx, result64, 0, "andq(4) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		for( mov( 0, ecx ); ecx < 64; inc( ecx )) do
	
			math.andq( pwrsOf2m1_64[edx*8], pwrsOf2m1_64[ecx*8], result64 );
			if( ecx <= edx ) then
			
				cmp64( edx, result64, pwrsOf2m1_64[ecx*8], "andq(5) failed!" );
			
			else
			
				cmp64( edx, result64, pwrsOf2m1_64[edx*8], "andq(6) failed!" );
				
			endif;
			
		endfor;
		
	endfor;
	stderr.put( "andq tests succeeded!" nl );
	
	
	
	
	
	
	// ANDL tests:
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.andl( pwrsOf2_128[edi*8], pwrsOf2_128[edi*8], result128 );
		cmp128( edx, result128, pwrsOf2_128[ edi*8 ], "andl(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.andl( pwrsOf2_128[edi*8], allOnes128, result128 );
		cmp128( edx, result128, pwrsOf2_128[ edi*8 ], "andl(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.andl( pwrsOf2_128[edi*8], 0, result128 );
		cmp128( edx, result128, 0, "andl(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.andl( altBits_128[edi*8], altBits2_128[edi*8], result128 );
		cmp128( edx, result128, 0, "andl(4) failed!" );
		
	endfor;
						
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		for( mov( 0, ecx ); ecx < 128; inc( ecx )) do
	
			lea( edi, [edx*2] );
			lea( esi, [ecx*2] );
			math.andl( pwrsOf2m1_128[edi*8], pwrsOf2m1_128[esi*8], result128 );
			if( ecx <= edx ) then
			
				cmp128( edx, result128, pwrsOf2m1_128[esi*8], "andl(5) failed!" );
			
			else
			
				cmp128( edx, result128, pwrsOf2m1_128[edi*8], "andl(6) failed!" );
				
			endif;
			
		endfor;
		
	endfor;
	stderr.put( "andl tests succeeded!" nl );
	
	
	
	
	// NOTQ tests:
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.notq( pwrsOf2_64[edx*8], result64 );
		cmp64( edx, result64, notPwrsOf2_64[ edx*8 ], "notq(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.notq( pwrsOf2m1_64[edx*8], result64 );
		cmp64( edx, result64, notPwrsOf2m1_64[ edx*8 ], "notq(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.notq( allOnes64, result64 );
		cmp64( edx, result64, 0, "notq(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		math.notq( altBits_64[edx*8], result64 );
		cmp64( edx, result64, notAltBits_64[edx*8], "notq(4) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		math.notq( altBits2_64[edx*8], result64 );
		cmp64( edx, result64, notAltBits2_64[edx*8], "notq(4) failed!" );
		
	endfor;
	stderr.put( "notq tests succeeded!" nl );
	
	
	
	
	
	
	// NOTL tests:
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.notl( pwrsOf2_128[edi*8], result128 );
		cmp128( edx, result128, notPwrsOf2_128[ edi*8 ], "notl(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.notl( pwrsOf2m1_128[edi*8], result128 );
		cmp128( edx, result128, notPwrsOf2m1_128[ edi*8 ], "notl(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.notl( allOnes128, result128 );
		cmp128( edx, result128, 0, "notl(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.notl( altBits_128[edi*8], result128 );
		cmp128( edx, result128, notAltBits_128[edi*8], "notl(4) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.notl( altBits2_128[edi*8], result128 );
		cmp128( edx, result128, notAltBits2_128[edi*8], "notl(4) failed!" );
		
	endfor;
	stderr.put( "notl tests succeeded!" nl );
	
	
	
	
	
	
	// ORQ tests:
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.orq( pwrsOf2_64[edx*8], pwrsOf2_64[edx*8], result64 );
		cmp64( edx, result64, pwrsOf2_64[ edx*8 ], "orq(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.orq( pwrsOf2_64[edx*8], allOnes64, result64 );
		cmp64( edx, result64, allOnes64, "orq(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.orq( pwrsOf2_64[edx*8], 0, result64 );
		cmp64( edx, result64, pwrsOf2_64[edx*8], "orq(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		math.orq( altBits_64[edx*8], altBits2_64[edx*8], result64 );
		cmp64( edx, result64, pairBits_64[edx*8], "orq(4) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		for( mov( 0, ecx ); ecx < 64; inc( ecx )) do
	
			math.orq( pwrsOf2m1_64[edx*8], pwrsOf2m1_64[ecx*8], result64 );
			if( ecx <= edx ) then
			
				cmp64( edx, result64, pwrsOf2m1_64[edx*8], "orq(5) failed!" );
			
			else
			
				cmp64( edx, result64, pwrsOf2m1_64[ecx*8], "orq(6) failed!" );
				
			endif;
			
		endfor;
		
	endfor;
	stderr.put( "orq tests succeeded!" nl );
	
	
	
	
	
	
	// ORL tests:
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.orl( pwrsOf2_128[edi*8], pwrsOf2_128[edi*8], result128 );
		cmp128( edx, result128, pwrsOf2_128[ edi*8 ], "orl(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.orl( pwrsOf2_128[edi*8], allOnes128, result128 );
		cmp128( edx, result128, allOnes128, "orl(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.orl( pwrsOf2_128[edi*8], 0, result128 );
		cmp128( edx, result128, pwrsOf2_128[edi*8], "orl(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.orl( altBits_128[edi*8], altBits2_128[edi*8], result128 );
		cmp128( edx, result128, pairBits_128[edi*8], "orl(4) failed!" );
		
	endfor;
						
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		for( mov( 0, ecx ); ecx < 128; inc( ecx )) do
	
			lea( edi, [edx*2] );
			lea( esi, [ecx*2] );
			math.orl( pwrsOf2m1_128[edi*8], pwrsOf2m1_128[esi*8], result128 );
			if( ecx <= edx ) then
			
				cmp128( edx, result128, pwrsOf2m1_128[edi*8], "orl(5) failed!" );
			
			else
			
				cmp128( edx, result128, pwrsOf2m1_128[esi*8], "orl(6) failed!" );
				
			endif;
			
		endfor;
		
	endfor;
	stderr.put( "orl tests succeeded!" nl );
	
	
	
	
	
	
	// XORQ tests:
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.xorq( pwrsOf2_64[edx*8], pwrsOf2_64[edx*8], result64 );
		cmp64( edx, result64, 0, "xorq(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.xorq( pwrsOf2_64[edx*8], allOnes64, result64 );
		cmp64( edx, result64, notPwrsOf2_64[edx*8], "xorq(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		math.xorq( pwrsOf2_64[edx*8], 0, result64 );
		cmp64( edx, result64, pwrsOf2_64[edx*8], "xorq(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		math.xorq( altBits_64[edx*8], altBits2_64[edx*8], result64 );
		cmp64( edx, result64, pairBits_64[edx*8], "xorq(4) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
	
		for( mov( 0, ecx ); ecx < 64; inc( ecx )) do
	
			mov( (type dword pwrsOf2m1_64[edx*8]), eax );
			xor( (type dword pwrsOf2m1_64[ecx*8]), eax );
			mov( eax, (type dword u64));
			mov( (type dword pwrsOf2m1_64[edx*8+4]), eax );
			xor( (type dword pwrsOf2m1_64[ecx*8+4]), eax );
			mov( eax, (type dword u64[4]));
			
			math.xorq( pwrsOf2m1_64[edx*8], pwrsOf2m1_64[ecx*8], result64 );
			cmp64( edx, result64, u64, "xorq(5) failed!" );
			
		endfor;
		
	endfor;
	stderr.put( "xorq tests succeeded!" nl );
	
	
	
	
	
	
	// XORL tests:
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.xorl( pwrsOf2_128[edi*8], pwrsOf2_128[edi*8], result128 );
		cmp128( edx, result128, 0, "xorl(1) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.xorl( pwrsOf2_128[edi*8], 0, result128 );
		cmp128( edx, result128, pwrsOf2_128[edi*8], "xorl(2) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.xorl( pwrsOf2_128[edi*8], allOnes128, result128 );
		cmp128( edx, result128, notPwrsOf2_128[edi*8], "xorl(3) failed!" );
		
	endfor;
	
	for( mov( 0, edx ); edx < 32; inc( edx )) do
	
		lea( edi, [edx*2] );
		math.xorl( altBits_128[edi*8], altBits2_128[edi*8], result128 );
		cmp128( edx, result128, pairBits_128[edi*8], "xorl(4) failed!" );
		
	endfor;
						
	
	for( mov( 0, edx ); edx < 128; inc( edx )) do
	
		for( mov( 0, ecx ); ecx < 128; inc( ecx )) do
	
			lea( edi, [edx*2] );
			lea( esi, [ecx*2] );
			mov( (type dword pwrsOf2m1_128[edi*8]), eax );
			xor( (type dword pwrsOf2m1_128[esi*8]), eax );
			mov( eax, (type dword u128));
			
			mov( (type dword pwrsOf2m1_128[edi*8+4]), eax );
			xor( (type dword pwrsOf2m1_128[esi*8+4]), eax );
			mov( eax, (type dword u128[4]));
			
			mov( (type dword pwrsOf2m1_128[edi*8+8]), eax );
			xor( (type dword pwrsOf2m1_128[esi*8+8]), eax );
			mov( eax, (type dword u128[8]));
			
			mov( (type dword pwrsOf2m1_128[edi*8+12]), eax );
			xor( (type dword pwrsOf2m1_128[esi*8+12]), eax );
			mov( eax, (type dword u128[12]));
			
			
			math.xorl( pwrsOf2m1_128[edi*8], pwrsOf2m1_128[esi*8], result128 );
			cmp128( edx, result128, u128, "xorl(6) failed!" );
			
		endfor;
		
	endfor;
	stderr.put( "xorl tests succeeded!" nl );
	
	
	
	
	stderr.put( "tLogical test succeeded!" nl );
	
	
end tLogical;	