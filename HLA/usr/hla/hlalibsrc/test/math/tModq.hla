// tArithmetic-
//
//	Tests the following MATH module functions:
//
//	addq, addl, divq, divl, idivq, idivl, imodq, imodl, imulq, imull,
//	modq, modl, mulq, mull, negq, negl, subq, subl.

program tArithmetic;
#include( "stdlib.hhf" )

val
	
	pwrsOf2_64_c	:uns64[] :=
		[
			#for( i := 0 to 63 )
				1 << i,
			#endfor
		];
	
	pwrsOf2m1_64_c	:uns64[] :=
		[
			#for( i := 0 to 63 )
				(1 << i) - 1,
			#endfor
		];
		
		
		
	divisors_64_c	:uns64[] :=
		[
			#for( i := 1 to 256 )
				i,
			#endfor
			257,
			65535,
			65536,
			65537,
			16*1024*1024-1,
			16*1024*1024,
			16*1024*1024+1,
			4*1024*1024*1024-1,
			4*1024*1024*1024,
			4*1024*1024*1024+1,
		];
		
	idivisors_64_c	:int64[] :=
		[
			#for( i := 0 to @elements( divisors_64_c )-1)
				divisors_64_c[i],
			#endfor
			#for( i := 0 to @elements( divisors_64_c )-1)
				-divisors_64_c[i],
			#endfor
		];
		
		
		
	// Bison limitation! Cannot have thousands of entries in
	// an array constant. So we'll fill each element individually.
	
	mods_64_c	:uns64[ 64 * @elements( divisors_64_c )];
			#for( i := 0 to 63 ) 
				#for( j := 0 to @elements( divisors_64_c )-1 )
				
					?mods_64_c[ i*@elements( divisors_64_c ) + j] :=
						pwrsOf2_64_c[i] mod divisors_64_c[j];
				
				#endfor
			#endfor				
	
	imods_64_c	:int64[ 64 * @elements( idivisors_64_c )];
			#for( i := 0 to 63 ) 
				#for( j := 0 to @elements( idivisors_64_c )-1 )
				
					?imods_64_c[ i*@elements( idivisors_64_c ) + j] :=
						pwrsOf2_64_c[i] mod idivisors_64_c[j];
										
				#endfor
			#endfor				
	
	
	
	
	
static
	i64				:int64;
	u64				:uns64;
	result64		:uns64;
	iresult64		:int64;
	
	one64			:uns64 := 1;
	allOnes64		:uns64 := $FFFF_FFFF_FFFF_FFFF;
	
	i128			:int128;
	u128			:uns128;
	result128		:uns128;
	iresult128		:int128;
	
readonly
	one128			:uns128 := 1;
	allOnes128		:uns128 := $FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF;
	
	pwrsOf2_64		:uns64[ @elements( pwrsOf2_64_c ) ] := pwrsOf2_64_c;
	
	
	divisors_64		:uns64[ @elements( divisors_64_c ) ] := divisors_64_c;
	mods_64			:uns64[ @elements( mods_64_c ) ] := mods_64_c;
	
	idivisors_64	:int64[ @elements( idivisors_64_c ) ] := idivisors_64_c;
	imods_64		:int64[ @elements( imods_64_c ) ] := imods_64_c;
	
	
procedure cmp64( index:uns32; testVal1:qword; testVal2:qword; msg:string );
begin cmp64;

	push( edx );
	mov( (type dword testVal1), eax );
	mov( (type dword testVal1[4]), edx );
	cmp( eax, (type dword testVal2));
	jne failed;
	cmp( edx, (type dword testVal2[4]));
	je succeeded;
	failed:
	
		stderr.put
		( 
			"Error: ", msg, nl
			"testVal1: ", testVal1, nl
			"testVal2: ", testVal2, nl
		);
		conv.setUnderscores( true );
		stderr.put
		(
			"index:    ", index, nl 
		);
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	succeeded:
	pop( edx );
	
end cmp64;

	

begin tArithmetic;
	
	
	// MODQ tests:
	
	for( mov( 0, edx ); edx < 64; inc( edx )) do
		
		for( mov( 0, ecx ); ecx < @elements( divisors_64 ); inc( ecx )) do
	
			math.modq( pwrsOf2_64[edx*8], divisors_64[ecx*8], result64 );
			intmul( @elements( divisors_64 ), edx, esi );
			add( ecx, esi );  
			cmp64( edx, result64, mods_64[ esi*8 ], "modq(1) failed!" );
			
		endfor;
		
	endfor;
	stderr.put( "modq tests succeeded!" nl );
	
	
	// IMODQ tests:
	
	for( mov( 0, edx ); edx < 63; inc( edx )) do
		
		for( mov( 0, ecx ); ecx < @elements( idivisors_64 ); inc( ecx )) do

			math.imodq( pwrsOf2_64[edx*8], idivisors_64[ecx*8], iresult64 );
			intmul( @elements( idivisors_64 ), edx, esi );
			add( ecx, esi );
			
			mov( edx, eax );
			intmul( 1000, eax );
			add( ecx, eax );  
			cmp64( eax, iresult64, imods_64[ esi*8 ], "imodq(1) failed!" );
			
		endfor;
		
	endfor;
	stderr.put( "imodq tests succeeded!" nl );
	
	
end tArithmetic;	