program tTrig;
#include( "stdlib.hhf" )

const
	dataPts	:= 16384;
	
static
	r80Val		:real80;
	
	r32			:real32;
	r32a		:real32;
	sin32		:real32;
	cos32		:real32;
	tan32		:real32;
	result32	:real32;
	
	r64			:real64;
	r64a		:real64;
	sin64		:real64;
	cos64		:real64;
	tan64		:real64;
	result64	:real64;
	
	r80			:real80;
	r80a		:real80;
	sin80		:real80;
	cos80		:real80;
	tan80		:real80;
	result80	:real80;
	
	increment	:real80;
	numIncs		:real80 := real80(dataPts);
	
	
procedure testErr32( r1:real32; r2:real32; sigma:real80; msg:string );
static
	r80	:real80;
	
begin testErr32;

	fld( r1 );
	fld( r2 );
	fsubp();
	fabs();
	fld( sigma );
	fcomip( st0, st1 );
	fstp( r80 );
	if( @nae ) then
	
		stderr.put
		( 
			"Error: ", msg, nl 
			"R1=", r1, " / $", (type dword r1), nl 
			"R2=", r2, " / $", (type dword r2), nl
			"sigma=", sigma, nl
			"r80=", r80, nl
		);
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
end testErr32;
	
	
procedure testErr64( r1:real64; r2:real64; sigma:real80; msg:string );
static
	r80	:real80;
	
begin testErr64;

	fld( r1 );
	fld( r2 );
	fsubp();
	fabs();
	fld( sigma );
	fcomip( st0, st1 );
	fstp( r80 );
	if( @nae ) then
	
		stderr.put
		( 
			"Error: ", msg, nl 
			"R1=", r1, " / $", (type dword r1), nl 
			"R2=", r2, " / $", (type dword r2), nl
			"sigma=", sigma, nl
			"r80=", r80, nl
		);
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
end testErr64;
	
	
	
procedure testErr80( r1:real80; r2:real80; sigma:real80; msg:string );
static
	r80	:real80;
	
begin testErr80;

	fld( r1 );
	fld( r2 );
	fsubp();
	fabs();
	fld( sigma );
	fcomip( st0, st1 );
	fstp( r80 );
	if( @nae ) then
	
		stderr.put
		( 
			"Error: ", msg, nl 
			"R1=", r1, " / $", (type dword r1), nl 
			"R2=", r2, " / $", (type dword r2), nl
			"sigma=", sigma, nl
			"r80=", r80, nl
		);
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
		
	endif;
	
end testErr80;
	

begin tTrig;	
	
	
	// numIncs is the # of loop iterations we'll perform.
	// Compute the real incremental value to go through 90 degrees
	// in that many loop iterations.  Note that the functions start to
	// get really inaccurate after pi/4 (90 degrees).
	
	fldpi();			// pi/2 = 90 degrees.
	fld( 2.0 );
	fdivp();
	fld( numIncs );		// Compute the angle increment value, per iteration.
	fdivp();
	fstp( increment );
	
	
	// First, do identity tests that don't requiring checking external data.
	// Begin with some "basis" tests to provide basic functionality tests
	// (so the remainder of the tests are meaningful, even if the functions
	// themselves are messed up).
	
	// sin(0) = 0
	
	math.sin32( 0.0 );
	fstp( result32 );
	testErr32( 0.0, result32, 5e-5, "sin32(0) failed!" );
	
	math.sin64( 0.0 );
	fstp( result64 );
	testErr64( 0.0, result64, 5e-14, "sin64(0) failed!" );
	
	math.sin80( 0.0 );
	fstp( result80 );
	testErr80( 0.0, result80, 5e-16, "sin80(0) failed!" );
	
	// sin(pi/2) = 1
	
	fldpi();
	fld( 2.0 );
	fdivp();
	fst( r32 );
	fst( r64 );
	fstp( r80 );
	
	math.sin32( r32 );
	fstp( result32 );
	testErr32( 1.0, result32, 5e-5, "sin32(pi/2) failed!" );
	
	math.sin64( r64 );
	fstp( result64 );
	testErr64( 1.0, result64, 5e-14, "sin64(pi/2) failed!" );
	
	math.sin80( r80 );
	fstp( result80 );
	testErr80( 1.0, result80, 5e-16, "sin80(pi/2) failed!" );
	
	// sin(pi/4) = sqrt(2)/2
	
	fldpi();
	fld( 4.0 );
	fdivp();
	fst( r32 );
	fst( r64 );
	fstp( r80 );
	
	math.sin32( r32 );
	fld( 2.0 );
	fmulp();
	fld( st0 );
	fmulp();
	fstp( result32 );
	testErr32( 2.0, result32, 5e-5, "sin32(pi/4) failed!" );
	
	math.sin64( r64 );
	fld( 2.0 );
	fmulp();
	fld( st0 );
	fmulp();
	fstp( result64 );
	testErr64( 2.0, result64, 5e-12, "sin64(pi/4) failed!" );
	
	math.sin80( r80 );
	fld( 2.0 );
	fmulp();
	fld( st0 );
	fmulp();
	fstp( result80 );
	testErr80( 2.0, result80, 5e-13, "sin80(pi/4) failed!" );
	
	
	// cos(0) = 1
	
	math.cos32( 0.0 );
	fstp( result32 );
	testErr32( 1.0, result32, 5e-5, "cos32(0) failed!" );
	
	math.cos64( 0.0 );
	fstp( result64 );
	testErr64( 1.0, result64, 5e-14, "cos64(0) failed!" );
	
	math.cos80( 0.0 );
	fstp( result80 );
	testErr80( 1.0, result80, 5e-16, "cos80(0) failed!" );
	
	// cos(pi/2) = 0
	
	fldpi();
	fld( 2.0 );
	fdivp();
	fst( r32 );
	fst( r64 );
	fstp( r80 );
	
	math.cos32( r32 );
	fstp( result32 );
	testErr32( 0.0, result32, 5e-5, "cos32(pi/2) failed!" );
	
	math.cos64( r64 );
	fstp( result64 );
	testErr64( 0.0, result64, 5e-14, "cos64(pi/2) failed!" );
	
	math.cos80( r80 );
	fstp( result80 );
	testErr80( 0.0, result80, 5e-16, "cos80(pi/2) failed!" );
	
	
	// cos(pi/4) = sqrt(2)/2
	
	fldpi();
	fld( 4.0 );
	fdivp();
	fst( r32 );
	fst( r64 );
	fstp( r80 );
	
	math.cos32( r32 );
	fld( 2.0 );
	fmulp();
	fld( st0 );
	fmulp();
	fstp( result32 );
	testErr32( 2.0, result32, 5e-5, "cos32(pi/4) failed!" );
	
	math.cos64( r64 );
	fld( 2.0 );
	fmulp();
	fld( st0 );
	fmulp();
	fstp( result64 );
	testErr64( 2.0, result64, 5e-12, "cos64(pi/4) failed!" );
	
	math.cos80( r80 );
	fld( 2.0 );
	fmulp();
	fld( st0 );
	fmulp();
	fstp( result80 );
	testErr80( 2.0, result80, 5e-13, "cos80(pi/4) failed!" );
	
	
	// tan(0) = 0
	
	math.tan32( 0.0 );
	fstp( result32 );
	testErr32( 0.0, result32, 5e-5, "tan32(0) failed!" );
	
	math.tan64( 0.0 );
	fstp( result64 );
	testErr64( 0.0, result64, 5e-14, "tan64(0) failed!" );
	
	math.tan80( 0.0 );
	fstp( result80 );
	testErr80( 0.0, result80, 5e-16, "tan80(0) failed!" );
	
	// tan( pi/4 ) = 1.
	
	fldpi();
	fld( 4.0 );
	fdivp();
	fst( r32 );
	fst( r64 );
	fstp( r80 );
	
	math.tan32( r32 );
	fstp( result32 );
	testErr32( 1.0, result32, 5e-5, "tan32(pi/4) failed!" );
	
	math.tan64( r64 );
	fstp( result64 );
	testErr64( 1.0, result64, 5e-12, "tan64(pi/4) failed!" );
	
	math.tan80( r80 );
	fstp( result80 );
	testErr80( 1.0, result80, 5e-13, "tan80(pi/4) failed!" );
	
	
	stderr.put( "trig basis tests succeeded!" nl );





	// Test sin/asin.
	// Compute the sin(x), then the asin(sin(x)) and compare the results
	// to see if they are equivalent (within some reasonable error tolerance).
	//
	// Run from 0..pi/4 (90 degrees).
	
	// 32-bit tests:
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.sin32( r32 );
		fstp( sin32 );
		math.asin32( sin32 );
		fstp( result32 );
		testErr32( r32, result32, 5e-4, "sin/asin32(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.sin32( r32 );
		fstp( sin32 );
		math.asin32( sin32 );
		fchs();
		fstp( result32 );
		testErr32( r32, result32, 5e-4, "sin/asin32(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 64-bit tests:
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.sin64( r64 );
		fstp( sin64 );
		math.asin64( sin64 );
		fstp( result64 );
		testErr64( r64, result64, 5e-12, "sin/asin64(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.sin64( r64 );
		fstp( sin64 );
		math.asin64( sin64 );
		fchs();
		fstp( result64 );
		testErr64( r64, result64, 5e-12, "sin/asin64(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 80-bit tests:
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.sin80( r80 );
		fstp( sin80 );
		math.asin80( sin80 );
		fstp( result80 );
		testErr80( r80, result80, 5e-13, "sin/asin80(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.sin80( r80 );
		fstp( sin80 );
		math.asin80( sin80 );
		fchs();
		fstp( result80 );
		testErr80( r80, result80, 5e-13, "sin/asin80(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "sin/asin succeeded!" nl );
	
	
	// Compute sin(x) and cos(x-3pi/2) and make sure
	// the results are identical:
	
	// 32-bit tests
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32a );
		math.sin( r32a );
		fstp( sin32 );
		
		fld( r80Val );
		fldpi();
		fld( 1.5 );
		fmulp();
		faddp();
		fstp( r32 );
		math.cos32( r32 );
		fstp( cos32 );
		testErr32( sin32, cos32, 5e-4, "cos/sin(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32a );
		math.sin( r32a );
		fstp( sin32 );
		
		fld( r80Val );
		fldpi();
		fld( 1.5 );
		fmulp();
		faddp();
		fstp( r32 );
		math.cos32( r32 );
		fstp( cos32 );
		testErr32( sin32, cos32, 5e-4, "cos/sin(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 64-bit tests
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64a );
		math.sin( r64a );
		fstp( sin64 );
		
		fld( r80Val );
		fldpi();
		fld( 1.5 );
		fmulp();
		faddp();
		fstp( r64 );
		math.cos64( r64 );
		fstp( cos64 );
		testErr64( sin64, cos64, 5e-12, "cos/sin(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64a );
		math.sin( r64a );
		fstp( sin64 );
		
		fld( r80Val );
		fldpi();
		fld( 1.5 );
		fmulp();
		faddp();
		fstp( r64 );
		math.cos64( r64 );
		fstp( cos64 );
		testErr64( sin64, cos64, 5e-12, "cos/sin(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 80-bit tests
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80a );
		math.sin( r80a );
		fstp( sin80 );
		
		fld( r80Val );
		fldpi();
		fld( 1.5 );
		fmulp();
		faddp();
		fstp( r80 );
		math.cos80( r80 );
		fstp( cos80 );
		testErr80( sin80, cos80, 5e-13, "cos/sin(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80a );
		math.sin( r80a );
		fstp( sin80 );
		
		fld( r80Val );
		fldpi();
		fld( 1.5 );
		fmulp();
		faddp();
		fstp( r80 );
		math.cos80( r80 );
		fstp( cos80 );
		testErr80( sin80, cos80, 5e-13, "cos/sin(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "cos/sin succeeded!" nl );
	
	
	
	
	
	
	// Compute sin(x)**2 + cos(x)**2 and make sure
	// their sum is one:
	
	// 32-bit tests
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32a );
		math.sin( r32a );
		fld( st0 );
		fmulp();
		fstp( sin32 );
		
		fld( r80Val );
		fstp( r32 );
		math.cos32( r32 );
		fld( st0 );
		fmulp();
		fadd( sin32 );
		fstp( result32 );
		testErr32( 1.0, result32, 5e-4, "sin**2+cos**2(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32a );
		math.sin( r32a );
		fld( st0 );
		fmulp();
		fstp( sin32 );
		
		fld( r80Val );
		fstp( r32 );
		math.cos32( r32 );
		fld( st0 );
		fmulp();
		fadd( sin32 );
		fstp( result32 );
		testErr32( 1.0, result32, 5e-4, "sin**2+cos**2(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 64-bit tests
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64a );
		math.sin( r64a );
		fld( st0 );
		fmulp();
		fstp( sin64 );
		
		fld( r80Val );
		fstp( r64 );
		math.cos64( r64 );
		fld( st0 );
		fmulp();
		fadd( sin64 );
		fstp( result64 );
		testErr64( 1.0, result64, 5e-12, "sin**2+cos**2(3) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64a );
		math.sin( r64a );
		fld( st0 );
		fmulp();
		fstp( sin64 );
		
		fld( r80Val );
		fstp( r64 );
		math.cos64( r64 );
		fld( st0 );
		fmulp();
		fadd( sin64 );
		fstp( result64 );
		testErr64( 1.0, result64, 5e-12, "sin**2+cos**2(4) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 80-bit tests
	
	fldz();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80a );
		math.sin( r80a );
		fld( st0 );
		fmulp();
		fstp( sin80 );
		
		fld( r80Val );
		fstp( r80 );
		math.cos80( r80 );
		fld( st0 );
		fmulp();
		fld( sin80 );
		faddp();
		fstp( result80 );
		testErr80( 1.0, result80, 5e-13, "sin**2+cos**2(5) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80a );
		math.sin( r80a );
		fld( st0 );
		fmulp();
		fstp( sin80 );
		
		fld( r80Val );
		fstp( r80 );
		math.cos80( r80 );
		fld( st0 );
		fmulp();
		fld( sin80 );
		faddp();
		fstp( result80 );
		testErr80( 1.0, result80, 5e-13, "sin**2+cos**2(6) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "sin**2 + cos**2 succeeded!" nl );
	
	
	
	
	
	
	// Test cos/acos.
	// Run from 0..pi/2 (90 degrees).
	
	// 32-bit tests
	
	fldz();
	fstp( r80Val );
	
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.cos32( r32 );
		fstp( cos32 );
		math.acos32( cos32 );
		fstp( result32 );
		testErr32( r32, result32, 4e-4, "cos/acos32(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.cos32( r32 );
		fstp( cos32 );
		math.acos32( cos32 );
		fchs();
		fstp( result32 );
		testErr32( r32, result32, 5e-4, "cos/acos32(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 64-bit tests
	
	fldz();
	fstp( r80Val );
	
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.cos64( r64 );
		fstp( cos64 );
		math.acos64( cos64 );
		fstp( result64 );
		testErr64( r64, result64, 5e-12, "cos/acos64(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.cos64( r64 );
		fstp( cos64 );
		math.acos64( cos64 );
		fchs();
		fstp( result64 );
		testErr64( r64, result64, 5e-12, "cos/acos64(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 80-bit tests
	
	fldz();
	fstp( r80Val );
	
	for( mov( 0, edx ); edx <= dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.cos80( r80 );
		fstp( cos80 );
		math.acos80( cos80 );
		fstp( result80 );
		testErr80( r80, result80, 5e-13, "cos/acos80(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.cos80( r80 );
		fstp( cos80 );
		math.acos80( cos80 );
		fchs();
		fstp( result80 );
		testErr80( r80, result80, 5e-13, "cos/acos80(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "cos/acos succeeded!" nl );
	
	
	
	
	
	
	
	
	
	// Test tan/atan.
	// Run from 0..<pi/2 (<90 degrees).
	// Note: tan(pi/2) is undefined.
	
	// 32-bit tests
	
	fldz();
	fstp( r80Val );
	
	for( mov( 0, edx ); edx <= dataPts-2; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.tan32( r32 );
		fstp( tan32 );
		math.atan32( tan32 );
		fstp( result32 );
		testErr32( r32, result32, 4e-4, "tan/atan32(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	// 64-bit tests
	
	fldz();
	fstp( r80Val );
	
	for( mov( 0, edx ); edx <= dataPts-2; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.tan64( r64 );
		fstp( tan64 );
		math.atan64( tan64 );
		fstp( result64 );
		testErr64( r64, result64, 5e-12, "tan/atan64(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	// 80-bit tests
	
	fldz();
	fstp( r80Val );
	
	for( mov( 0, edx ); edx <= dataPts-2; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.tan80( r80 );
		fstp( tan80 );
		math.atan80( tan80 );
		fstp( result80 );
		testErr80( r80, result80, 5e-13, "tan/atan80(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "tan/atan succeeded!" nl );
	
	
	
	// Sine/Cosecant tests (note: csc = 1/sin)
	
	
	// 32-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.sin32( r32 );
		fld1();
		fdivrp();
		fstp( sin32 );
		math.csc32( r32 );
		fstp( result32 );
		testErr32( sin32, result32, 5e-4, "sin/csc32(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.sin32( r32 );
		fld1();
		fdivrp();
		fstp( sin32 );
		
		math.csc32( r32 );
		fstp( result32 );
		testErr32( sin32, result32, 5e-4, "sin/csc32(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	// 64-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.sin64( r64 );
		fld1();
		fdivrp();
		fstp( sin64 );
		math.csc64( r64 );
		fstp( result64 );
		testErr64( sin64, result64, 5e-4, "sin/csc64(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.sin64( r64 );
		fld1();
		fdivrp();
		fstp( sin64 );
		
		math.csc64( r64 );
		fstp( result64 );
		testErr64( sin64, result64, 5e-4, "sin/csc64(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	// 80-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.sin80( r80 );
		fld1();
		fdivrp();
		fstp( sin80 );
		math.csc80( r80 );
		fstp( result80 );
		testErr80( sin80, result80, 5e-4, "sin/csc80(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.sin80( r80 );
		fld1();
		fdivrp();
		fstp( sin80 );
		
		math.csc80( r80 );
		fstp( result80 );
		testErr80( sin80, result80, 5e-4, "sin/csc80(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "sin/csc succeeded!" nl );
	
	
		
	
	
	
	// cosine/secant tests (note: sec = 1/cos)
	
	
	// 32-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.cos32( r32 );
		fld1();
		fdivrp();
		fstp( cos32 );
		math.sec32( r32 );
		fstp( result32 );
		testErr32( cos32, result32, 5e-4, "cos/sec32(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.cos32( r32 );
		fld1();
		fdivrp();
		fstp( cos32 );
		
		math.sec32( r32 );
		fstp( result32 );
		testErr32( cos32, result32, 5e-4, "cos/sec32(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	// 64-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.cos64( r64 );
		fld1();
		fdivrp();
		fstp( cos64 );
		math.sec64( r64 );
		fstp( result64 );
		testErr64( cos64, result64, 5e-4, "cos/sec64(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.cos64( r64 );
		fld1();
		fdivrp();
		fstp( cos64 );
		
		math.sec64( r64 );
		fstp( result64 );
		testErr64( cos64, result64, 5e-4, "cos/sec64(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	// 80-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.cos80( r80 );
		fld1();
		fdivrp();
		fstp( cos80 );
		math.sec80( r80 );
		fstp( result80 );
		testErr80( cos80, result80, 5e-4, "cos/sec80(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.cos80( r80 );
		fld1();
		fdivrp();
		fstp( cos80 );
		
		math.sec80( r80 );
		fstp( result80 );
		testErr80( cos80, result80, 5e-4, "cos/sec80(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "cos/sec succeeded!" nl );
	
	
		
	
	
	
	// tangent/cotangent tests (note: cot = 1/tan)
	
	
	// 32-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.tan32( r32 );
		fld1();
		fdivrp();
		fstp( tan32 );
		math.cot32( r32 );
		fstp( result32 );
		testErr32( tan32, result32, 5e-4, "tan/cot32(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r32 );
		math.tan32( r32 );
		fld1();
		fdivrp();
		fstp( tan32 );
		
		math.cot32( r32 );
		fstp( result32 );
		testErr32( tan32, result32, 5e-4, "tan/cot32(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	// 64-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.tan64( r64 );
		fld1();
		fdivrp();
		fstp( tan64 );
		math.cot64( r64 );
		fstp( result64 );
		testErr64( tan64, result64, 5e-4, "tan/cot64(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r64 );
		math.tan64( r64 );
		fld1();
		fdivrp();
		fstp( tan64 );
		
		math.cot64( r64 );
		fstp( result64 );
		testErr64( tan64, result64, 5e-4, "tan/cot64(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	
	// 80-bit tests:
	
	fld(increment);
	fstp( r80Val );
	for( mov( 0, edx ); edx <= dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.tan80( r80 );
		fld1();
		fdivrp();
		fstp( tan80 );
		math.cot80( r80 );
		fstp( result80 );
		testErr80( tan80, result80, 5e-4, "tan/cot80(1) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	
	fldpi();
	fld( -2.0 );
	fdivp();
	fld( increment );
	faddp();
	fstp( r80Val );
	for( mov( 0, edx ); edx < dataPts-1; inc( edx )) do
	
		fld( r80Val );
		fstp( r80 );
		math.tan80( r80 );
		fld1();
		fdivrp();
		fstp( tan80 );
		
		math.cot80( r80 );
		fstp( result80 );
		testErr80( tan80, result80, 5e-4, "tan/cot80(2) failed!" );

		fld( increment );
		fld( r80Val );
		faddp();
		fstp( r80Val );
		
	endfor;
	stderr.put( "tan/cot succeeded!" nl );
	
	
end tTrig;	