program readln_test;
#include( "stdlib.hhf" )

// Input test file:
//
//  1st line:  #$0d #$0a
//  2nd line:  abc #$0d #$0a
//  3rd line:  asdf #$0d #$0a
//  4th line:  def #$0d #$0a
//  5th line:  #$0d #$0a
//
// Note, however, that the stdin routines throw away the carriage return
// characters that appear immediately before a linefeed character.
					 
begin readln_test;

	try

		
		// Get the 1st (blank) line from the file:

		stdin.readLn();

		// Force the system to reject that line:

		stdin.flushInput();

		// The following will force the read of the second line:

		stdin.a_gets();
		mov( eax, ebx );
		if( str.ne( eax, "abc" )) then

			stderr.put
			( 
				"(1) stdin.a_gets should return 'abc'" nl
			);
			stdout.put( "Press Enter to Continue: " );
			stdin.readLn();
			os.exitProcess(1);

		endif;
		str.free( ebx );
		
		// Read two lines and verify that we've gotten the second one:
		
		stdin.readLn();
		stdin.readLn();
		stdin.a_gets();
		mov( eax, ebx );
		if( str.ne( eax, "def" )) then

			stderr.put
			( 
				"(2) stdin.a_gets should return 'def'" nl
			);
			os.exitProcess( 2 );

		endif;
		str.free( ebx );

		// From this point forward, we should just get empty strings.

		for( mov( 0, ecx ); ecx < 10; inc( ecx )) do

			stdin.readLn();
			stdin.a_gets();
			mov( eax, ebx );
			str.length( eax );
			if( eax <> 0 ) then

				stderr.put
				( 
					"(3) stdin.a_gets should return an empty string" nl
				);
				os.exitProcess( 3 );

			endif;
			str.free( ebx );

		endfor;
		
	  exception( ex.EndOfFile )

		stderr.put( "stdin successfully encountered end of file" nl );
		
	  anyexception

		stderr.put
		( 
			nl nl 
			"***************************************************" nl
			"stdin.readln/flushBuffer failed! Exception = ", eax,  nl
			"***************************************************" nl
			nl 
		);
		os.exitProcess(3);
		
	endtry;

	stderr.put( "readln/flushInput tests succeeded!" nl );
			
end readln_test;

													