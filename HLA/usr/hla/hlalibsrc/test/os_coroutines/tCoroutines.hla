program tCoroutines;
#include( "stdlib.hhf" )

static
	state	:dword;
	cor1	:coroutine;
	cor2	:coroutine;
	
	procedure coroutine1;
	begin coroutine1;
	
		or( @{0}, state );
		stdout.put( "From coroutine1, calling coroutine2(a)" nl );
		cor2.cocall();
		
		or( @{1}, state );
		stdout.put( "From coroutine1, calling main program(b)" nl );
		mainPgm_coroutine.cocall();
		
		or( @{2}, state );
		stdout.put( "Inside coroutine1, running off the end(c)" nl );
		
	end coroutine1;
	
	procedure coroutine2;
	begin coroutine2;
	
		or( @{3}, state );
		stdout.put( "From coroutine2, calling main program(d)" nl );
		mainPgm_coroutine.cocall();
		
		or( @{4}, state );
		stdout.put( "From coroutine2, coreturning to main program(e)" nl );
		coret();	// Return to main program.
		
		or( @{5}, state );
		stdout.put( "From coroutine2, calling coroutine1(f)" nl );
		cor1.cocall();
		
		or( @{31}, state );	// Should *not* be set!
		
	end coroutine2;
	
begin tCoroutines;

		
	cor1.create( 4096, &coroutine1 );
	cor2.create( 4096, &coroutine2 );
	
	mov( 0, state );
	stdout.put( "From main program, calling cor1(g)" nl );
	cor1.cocall();
	or( @{6}, state );
	
	stdout.put( "From main program, calling cor2(h)", nl );
	cor2.cocall();
	or( @{7}, state );
	
	stdout.put( "From main program, calling cor2(i)", nl );
	cor2.cocall();
	or( @{8}, state );
	
	stdout.put( "From main program, freeing cor2(j)" nl );
	cor2.cofree();
	or( @{9}, state );
	
	stdout.put( "From main program, calling cor1(k)", nl );
	cor1.cocall();
	
	or( @{10}, state );
	stdout.put( "Back in main program, terminating(l)" nl );
	
	if
	( 
		state <>
		(
			@{0} | @{1} | @{2} | @{3} | 	
			@{4} | @{5} | @{6} | @{7} | 	
			@{8} | @{9} | @{10}
		)
	) then
	
		stderr.put( "Coroutines module failed! state=$", state, nl );
		stdout.put( "Press Enter to Continue: " );
		stdin.readLn();
		os.exitProcess(1);
	
	endif;
	stderr.put( "tCoroutines succeeded!" nl );
	
end tCoroutines;
