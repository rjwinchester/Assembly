program delete;
#include( "stdlib.hhf" )
#if( os.win32 )
	#include( "w.hhf" )
#elseif( os.linux )
	#include( "linux.hhf" )
#elseif( os.freeBSD )
	#include( "bsd.hhf" )
#endif

#macro pushRegs;
	push( ebx );
	push( ecx );
	push( edx );
	push( esi );
	push( edi );
#endmacro;

#macro popRegs;
	pop( edi );
	pop( esi );
	pop( edx );
	pop( ecx );
	pop( ebx );
#endmacro;


#if( !@defined( HLAstdlibVersion ))
	?HLAstdlibVersion := 1;
#endif
#if( HLAstdlibVersion < 2 )

	namespace filesys;


		procedure delete( filename:string ); 
			@returns( "EAX" ); 
			@external( "STDIO_FDELETE" );

		procedure cd( directory:string ); 
			@returns( "EAX" ); 
			@external( "STDIO_FCD" );

		procedure exists( FileName:string ); 
			@returns( "EAX" ); 
			@external( "STDIO_FEXISTS" );
			
		iterator fileWithSuffix( directory:string; suffix:string );
			@external( "FILESYS_FILEWITHSUFFIX" );
				
		procedure gwd( directory:string ); 
			@external( "FILESYS_GWD" );
		
		procedure isDir( FileName:string );
			@returns( "al" ); 
			@external( "FILESYS_ISDIR" );
					

	end filesys;
	
	#if( os.linux )


		procedure filesys.isDir( FileName:string ); @nodisplay; @noframe;
		var
			s	:linux.stat_t;
			
		begin isDir;

			push( ebp );
			mov( esp, ebp );
			sub( _vars_, esp );
			
			push( ecx );
			push( edx );

			linux.stat( FileName, s );
			test( eax, eax );
			jnz failure;
			
				movzx( s.st_mode, eax );
				and( linux.s_ifdir, eax );
				jz notDir;
					mov( 1, eax );
					jmp notDir;
					
			failure:
				xor( eax, eax );
			
			notDir:
			pop( edx );
			pop( ecx );
			leave();
			ret( _parms_ );
			
		end isDir;
		
		
	#elseif( os.win32 )

		#include( "w.hhf" )

		procedure filesys.isDir( FileName:string ); @nodisplay; @noframe;
		begin isDir;

			push( ebp );
			mov( esp, ebp );
			push( ecx );
			push( edx );
			pushfd();
			cld();
			
			w.GetFileAttributes( FileName );
			not( eax );
			test( eax, eax );
			jz allDone;
				
				not( eax );
				and( w.FILE_ATTRIBUTE_DIRECTORY, eax );
				setne( al );
				movzx( al, eax );
				
			allDone:		
			popfd();
			pop( edx );
			pop( ecx );
			pop( ebp );
			ret( _parms_ );
			
		end isDir;
		
	#endif
	

	#if( os.linux )

		procedure filesys.gwd( directory:string ); @nodisplay;
		var
			maxLen:dword;
		begin gwd;

			push( eax );
			push( ebx );
			mov( directory, eax );
			linux.getcwd
			( 
				[eax], 
				(type linux.size_t (type str.strRec [eax]).MaxStrLen) 
			);
			if( eax = 0 ) then
			
				// Assume that a NULL return value means string overflow.

				raise( ex.StringOverflow );

			else
			
				// We have to compute the length of the string since
				// Linux doesn't do that for us.  Since Linux already
				// checked for string overflow and zero-terminated the
				// string, we don't have to deal with that.
				
				mov( directory, ebx );
				mov( 0, al );
				while( al <> [ebx] ) do
				
					inc( ebx );
					
				endwhile;
				mov( directory, eax );
				sub( eax, ebx );		// Compute string length.
				mov( ebx, (type str.strRec [eax]).length );
				
			endif;
			
			pop( ebx );
			pop( eax );
			
		end gwd;

	#elseif( os.win32 )

		procedure filesys.gwd( directory:string ); @nodisplay; @noalignstack;
		var
			maxLen:dword;
		begin gwd;

			push( eax );
			pushRegs;
			pushfd();
			cld();

			// Compute the maximum path length possible.  Note that
			// "SetCurrentDirectory" expects this count to include
			// room for a zero terminating byte (whereas the maxlen
			// field of an HLA string does not include this).

			mov( directory, ebx );
			mov( (type str.strRec [ebx]).MaxStrLen, eax );
			mov( eax, maxLen );  // Save so we can test for success later.
			inc( eax );

			// Okay, get the pathname:

			w.GetCurrentDirectory( eax, directory );
			if( eax = maxLen ) then

				// The pathname was too long for the string, raise an exception.

				raise( ex.StringOverflow );

			endif;
			mov( eax, (type str.strRec [ebx]).length );
			popfd();
			popRegs;
			pop( eax );
			
		end gwd;

	#endif


	


	#if( os.win32 )

		iterator filesys.fileWithSuffix( directory:string; suffix:string ); @nodisplay;
		var
			handle		:dword;
			wildCard	:string;
			FileData	:w.WIN32_FIND_DATA;
			stringBuf	:char[1024];
			
		begin fileWithSuffix;

			// Initialize string that will hold the wildcard sequence:
			
			str.init( stringBuf, 1024 );
			mov( eax, wildCard );
			str.cpy( "*", wildCard );
			str.cat( suffix, wildCard );
			 
			// Find the first matching file (if one exists).
			// Save the handle for use by FindNextFile.
			
			push( ecx );
			push( edx );
			w.FindFirstFile( wildCard, FileData );
			mov( eax, handle );
			pop( edx );
			pop( ecx );
			
			// If we matched at least one filename, return
			// the corresponding string and call the
			// FindNextFile routine to match any additional
			// filenames.
			
			if( eax <> w.INVALID_HANDLE_VALUE ) then
			
				repeat
				
					
					// FindFirstFile & FindNextFile return
					// zero-terminated strings.  Convert these
					// to HLA compatible strings and return
					// the converted string:
					
					lea( eax, FileData.cFileName );
					#if( HLAstdlibVersion < 2 )
					
						str.a_cpyz( [eax] );
					
					#else
					
						str.a_cpyz( eax );
						
					#endif

					// Return the converted string to the FOREACH
					// loop and then free the storage associated
					// with the string.
					
					yield();		// Return string to FOREACH loop.
				
					// Get the next filename in the list:
					
					push( ecx );
					push( edx );
					w.FindNextFile( handle, FileData );
					pop( edx );
					pop( ecx );

				until( al = false );
				
				// When we've processed all the filenames in the list,
				// call FindClose to free the handle and other resources.
				
				push( ecx );
				push( edx );
				w.FindClose( handle );
				pop( edx );
				pop( ecx );
				
			endif;

		end fileWithSuffix;
		
	#elseif( os.linux )

		iterator filesys.fileWithSuffix( directory:string; suffix:string ); @nodisplay;
		var
			handle		:dword;
			filename	:string;
			suffixLen	:dword;
			eaxSave		:dword;
			ebxSave		:dword;
			ecxSave		:dword;
			edxSave		:dword;
			ediSave		:dword;
			esiSave		:dword;
			s			:linux.stat_t;
			dBuf		:byte[4096];
			
			
		begin fileWithSuffix;

			mov( esi, esiSave );
			mov( edi, ediSave );
			mov( edx, edxSave );
			mov( ecx, ecxSave );
			mov( ebx, ebxSave );
			mov( eax, eaxSave );
			pushfd();
			
			str.length( suffix );
			mov( eax, suffixLen );
			
			linux.open( ".", linux.o_rdonly, linux.s_irwxu );
			mov( eax, handle );
			if( eax <> NULL ) then

				forever

					linux.getdents
					( 
						handle, 
						(type linux.dirent dBuf), 
						@size(dBuf) 
					);
					breakif( (type int32 eax) <= 0 );
					mov( eax, ecx );
					lea( ebx, dBuf );
					repeat

						#if( HLAstdlibVersion < 2 )
						
							str.a_cpyz( (type linux.dirent [ebx]).d_name );
						
						#else
						
							lea( eax, (type linux.dirent [ebx]).d_name );
							str.a_cpyz( eax );
							
						#endif
						mov( eax, filename );
						mov( (type str.strRec [eax]).length, eax );
						if( eax >= suffixLen ) then
						
							push( ecx );
							mov( suffixLen, ecx );
							test( ecx, ecx );		// Always match if empty
							if( @nz ) then
							
								mov( filename, esi );
								add( (type str.strRec [esi]).length, esi );
								sub( ecx, esi );
								mov( suffix, edi );
								cld();
								repe.cmpsb();
								
							endif;
							if( @e ) then
							
								push( ebx );
								mov( esiSave, esi );
								mov( ediSave, edi );
								mov( edxSave, edx );
								mov( ecxSave, ecx );
								mov( ebxSave, ebx );
								mov( filename, eax );
								yield();
								mov( esi, esiSave );
								mov( edi, ediSave );
								mov( edx, edxSave );
								mov( ecx, ecxSave );
								mov( ebx, ebxSave );
								pop( ebx );
								
							endif;
							pop( ecx );
							
						else
						
							str.free( filename );
							
						endif;
							 
						movzx( (type linux.dirent[ebx]).d_reclen, edx );
						sub( edx, ecx );
						add( edx, ebx );

					until( (type int32 ecx) <= 0 );

				endfor;

			endif;
			linux.close(handle);
			mov( esiSave, esi );
			mov( ediSave, edi );
			mov( edxSave, edx );
			mov( ecxSave, ecx );
			mov( ebxSave, ebx );
			mov( eaxSave, eax );
			popfd();

		end fileWithSuffix;
		
	#endif
	
#endif




static
	toDelete	:string;
	origDir		:str.strvar(1024);
	msg			:str.strvar( 256 );
	delDirCmd	:str.strvar( 1024 );
	
	procedure deleteFile( fname:string );
	begin deleteFile;
	
		push( eax );
		if( str.ne( fname, "." ) && str.ne( fname, ".." )) then
		
			if( filesys.isDir( fname )) then
			
				filesys.cd( fname );
				foreach filesys.fileWithSuffix( ".", "" ) do

					deleteFile( eax );
					str.free( eax );
				
				endfor;
				filesys.cd( ".." );
				
							 
			else // it's just a file, delete it
			
				try

					filesys.delete( fname );
					
				  anyexception
				  
				  	// Ignore files we can't delete
					
				endtry;
				
			endif;
			
		endif;
		pop( eax );

	end deleteFile;
	
begin delete;

	filesys.gwd( origDir );

	if( arg.c() <> 2 ) then
	
		stderr.put( "usage: delete {.name | dirName}" nl );
		os.exitProcess(1);
		
	endif;
	arg.a_v(1);
	mov( eax, toDelete );

	if( filesys.isDir( toDelete )) then
	
		deleteFile( toDelete );
			
	else
	

		foreach filesys.fileWithSuffix( ".", toDelete ) do
		
			deleteFile( eax );
			str.free( eax );
		
		endfor;
		
	endif;
	filesys.cd( origDir );
	os.exitProcess( 0 );
		 
end delete;